// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: multichain.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_multichain_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_multichain_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_multichain_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_multichain_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_multichain_2eproto;
namespace multichain {
namespace v1 {
class CalculateSha256Request;
class CalculateSha256RequestDefaultTypeInternal;
extern CalculateSha256RequestDefaultTypeInternal _CalculateSha256Request_default_instance_;
class CalculateSha256Response;
class CalculateSha256ResponseDefaultTypeInternal;
extern CalculateSha256ResponseDefaultTypeInternal _CalculateSha256Response_default_instance_;
class CancelRequest;
class CancelRequestDefaultTypeInternal;
extern CancelRequestDefaultTypeInternal _CancelRequest_default_instance_;
class CancelResponse;
class CancelResponseDefaultTypeInternal;
extern CancelResponseDefaultTypeInternal _CancelResponse_default_instance_;
class GenAggregatedMultichainProofRequest;
class GenAggregatedMultichainProofRequestDefaultTypeInternal;
extern GenAggregatedMultichainProofRequestDefaultTypeInternal _GenAggregatedMultichainProofRequest_default_instance_;
class GenAggregatedMultichainProofResponse;
class GenAggregatedMultichainProofResponseDefaultTypeInternal;
extern GenAggregatedMultichainProofResponseDefaultTypeInternal _GenAggregatedMultichainProofResponse_default_instance_;
class GenFinalMultichainProofRequest;
class GenFinalMultichainProofRequestDefaultTypeInternal;
extern GenFinalMultichainProofRequestDefaultTypeInternal _GenFinalMultichainProofRequest_default_instance_;
class GenFinalMultichainProofResponse;
class GenFinalMultichainProofResponseDefaultTypeInternal;
extern GenFinalMultichainProofResponseDefaultTypeInternal _GenFinalMultichainProofResponse_default_instance_;
class GenPrepareMultichainProofRequest;
class GenPrepareMultichainProofRequestDefaultTypeInternal;
extern GenPrepareMultichainProofRequestDefaultTypeInternal _GenPrepareMultichainProofRequest_default_instance_;
class GenPrepareMultichainProofResponse;
class GenPrepareMultichainProofResponseDefaultTypeInternal;
extern GenPrepareMultichainProofResponseDefaultTypeInternal _GenPrepareMultichainProofResponse_default_instance_;
class GetProofRequest;
class GetProofRequestDefaultTypeInternal;
extern GetProofRequestDefaultTypeInternal _GetProofRequest_default_instance_;
class GetProofResponse;
class GetProofResponseDefaultTypeInternal;
extern GetProofResponseDefaultTypeInternal _GetProofResponse_default_instance_;
class GetStatusRequest;
class GetStatusRequestDefaultTypeInternal;
extern GetStatusRequestDefaultTypeInternal _GetStatusRequest_default_instance_;
class GetStatusResponse;
class GetStatusResponseDefaultTypeInternal;
extern GetStatusResponseDefaultTypeInternal _GetStatusResponse_default_instance_;
class MultichainMessage;
class MultichainMessageDefaultTypeInternal;
extern MultichainMessageDefaultTypeInternal _MultichainMessage_default_instance_;
class PrepareProof;
class PrepareProofDefaultTypeInternal;
extern PrepareProofDefaultTypeInternal _PrepareProof_default_instance_;
class ProverMessage;
class ProverMessageDefaultTypeInternal;
extern ProverMessageDefaultTypeInternal _ProverMessage_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace v1
}  // namespace multichain
PROTOBUF_NAMESPACE_OPEN
template<> ::multichain::v1::CalculateSha256Request* Arena::CreateMaybeMessage<::multichain::v1::CalculateSha256Request>(Arena*);
template<> ::multichain::v1::CalculateSha256Response* Arena::CreateMaybeMessage<::multichain::v1::CalculateSha256Response>(Arena*);
template<> ::multichain::v1::CancelRequest* Arena::CreateMaybeMessage<::multichain::v1::CancelRequest>(Arena*);
template<> ::multichain::v1::CancelResponse* Arena::CreateMaybeMessage<::multichain::v1::CancelResponse>(Arena*);
template<> ::multichain::v1::GenAggregatedMultichainProofRequest* Arena::CreateMaybeMessage<::multichain::v1::GenAggregatedMultichainProofRequest>(Arena*);
template<> ::multichain::v1::GenAggregatedMultichainProofResponse* Arena::CreateMaybeMessage<::multichain::v1::GenAggregatedMultichainProofResponse>(Arena*);
template<> ::multichain::v1::GenFinalMultichainProofRequest* Arena::CreateMaybeMessage<::multichain::v1::GenFinalMultichainProofRequest>(Arena*);
template<> ::multichain::v1::GenFinalMultichainProofResponse* Arena::CreateMaybeMessage<::multichain::v1::GenFinalMultichainProofResponse>(Arena*);
template<> ::multichain::v1::GenPrepareMultichainProofRequest* Arena::CreateMaybeMessage<::multichain::v1::GenPrepareMultichainProofRequest>(Arena*);
template<> ::multichain::v1::GenPrepareMultichainProofResponse* Arena::CreateMaybeMessage<::multichain::v1::GenPrepareMultichainProofResponse>(Arena*);
template<> ::multichain::v1::GetProofRequest* Arena::CreateMaybeMessage<::multichain::v1::GetProofRequest>(Arena*);
template<> ::multichain::v1::GetProofResponse* Arena::CreateMaybeMessage<::multichain::v1::GetProofResponse>(Arena*);
template<> ::multichain::v1::GetStatusRequest* Arena::CreateMaybeMessage<::multichain::v1::GetStatusRequest>(Arena*);
template<> ::multichain::v1::GetStatusResponse* Arena::CreateMaybeMessage<::multichain::v1::GetStatusResponse>(Arena*);
template<> ::multichain::v1::MultichainMessage* Arena::CreateMaybeMessage<::multichain::v1::MultichainMessage>(Arena*);
template<> ::multichain::v1::PrepareProof* Arena::CreateMaybeMessage<::multichain::v1::PrepareProof>(Arena*);
template<> ::multichain::v1::ProverMessage* Arena::CreateMaybeMessage<::multichain::v1::ProverMessage>(Arena*);
template<> ::multichain::v1::Version* Arena::CreateMaybeMessage<::multichain::v1::Version>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace multichain {
namespace v1 {

enum GetStatusResponse_Status : int {
  GetStatusResponse_Status_STATUS_UNSPECIFIED = 0,
  GetStatusResponse_Status_STATUS_BOOTING = 1,
  GetStatusResponse_Status_STATUS_COMPUTING = 2,
  GetStatusResponse_Status_STATUS_IDLE = 3,
  GetStatusResponse_Status_STATUS_HALT = 4,
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetStatusResponse_Status_GetStatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetStatusResponse_Status_IsValid(int value);
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MIN = GetStatusResponse_Status_STATUS_UNSPECIFIED;
constexpr GetStatusResponse_Status GetStatusResponse_Status_Status_MAX = GetStatusResponse_Status_STATUS_HALT;
constexpr int GetStatusResponse_Status_Status_ARRAYSIZE = GetStatusResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetStatusResponse_Status_descriptor();
template<typename T>
inline const std::string& GetStatusResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetStatusResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetStatusResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetStatusResponse_Status_descriptor(), enum_t_value);
}
inline bool GetStatusResponse_Status_Parse(
    const std::string& name, GetStatusResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetStatusResponse_Status>(
    GetStatusResponse_Status_descriptor(), name, value);
}
enum GetProofResponse_Result : int {
  GetProofResponse_Result_RESULT_UNSPECIFIED = 0,
  GetProofResponse_Result_RESULT_COMPLETED_OK = 1,
  GetProofResponse_Result_RESULT_ERROR = 2,
  GetProofResponse_Result_RESULT_COMPLETED_ERROR = 3,
  GetProofResponse_Result_RESULT_PENDING = 4,
  GetProofResponse_Result_RESULT_INTERNAL_ERROR = 5,
  GetProofResponse_Result_RESULT_CANCEL = 6,
  GetProofResponse_Result_GetProofResponse_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GetProofResponse_Result_GetProofResponse_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GetProofResponse_Result_IsValid(int value);
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MIN = GetProofResponse_Result_RESULT_UNSPECIFIED;
constexpr GetProofResponse_Result GetProofResponse_Result_Result_MAX = GetProofResponse_Result_RESULT_CANCEL;
constexpr int GetProofResponse_Result_Result_ARRAYSIZE = GetProofResponse_Result_Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetProofResponse_Result_descriptor();
template<typename T>
inline const std::string& GetProofResponse_Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetProofResponse_Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetProofResponse_Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetProofResponse_Result_descriptor(), enum_t_value);
}
inline bool GetProofResponse_Result_Parse(
    const std::string& name, GetProofResponse_Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetProofResponse_Result>(
    GetProofResponse_Result_descriptor(), name, value);
}
enum Result : int {
  RESULT_UNSPECIFIED = 0,
  RESULT_OK = 1,
  RESULT_ERROR = 2,
  RESULT_INTERNAL_ERROR = 3,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = RESULT_UNSPECIFIED;
constexpr Result Result_MAX = RESULT_INTERNAL_ERROR;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    const std::string& name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class Version PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.Version) */ {
 public:
  inline Version() : Version(nullptr) {};
  virtual ~Version();

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV001FieldNumber = 1,
  };
  // string v0_0_1 = 1;
  void clear_v0_0_1();
  const std::string& v0_0_1() const;
  void set_v0_0_1(const std::string& value);
  void set_v0_0_1(std::string&& value);
  void set_v0_0_1(const char* value);
  void set_v0_0_1(const char* value, size_t size);
  std::string* mutable_v0_0_1();
  std::string* release_v0_0_1();
  void set_allocated_v0_0_1(std::string* v0_0_1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_v0_0_1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_v0_0_1(
      std::string* v0_0_1);
  private:
  const std::string& _internal_v0_0_1() const;
  void _internal_set_v0_0_1(const std::string& value);
  std::string* _internal_mutable_v0_0_1();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v0_0_1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class MultichainMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.MultichainMessage) */ {
 public:
  inline MultichainMessage() : MultichainMessage(nullptr) {};
  virtual ~MultichainMessage();

  MultichainMessage(const MultichainMessage& from);
  MultichainMessage(MultichainMessage&& from) noexcept
    : MultichainMessage() {
    *this = ::std::move(from);
  }

  inline MultichainMessage& operator=(const MultichainMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultichainMessage& operator=(MultichainMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultichainMessage& default_instance();

  enum RequestCase {
    kGetStatusRequest = 2,
    kGenPrepareMultichainProofRequest = 3,
    kGenAggregatedMultichainProofRequest = 4,
    kGenFinalMultichainProofRequest = 5,
    kCancelRequest = 6,
    kGetProofRequest = 7,
    kCalculateSha256Request = 8,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultichainMessage* internal_default_instance() {
    return reinterpret_cast<const MultichainMessage*>(
               &_MultichainMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MultichainMessage& a, MultichainMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MultichainMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultichainMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultichainMessage* New() const final {
    return CreateMaybeMessage<MultichainMessage>(nullptr);
  }

  MultichainMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultichainMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultichainMessage& from);
  void MergeFrom(const MultichainMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultichainMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.MultichainMessage";
  }
  protected:
  explicit MultichainMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGetStatusRequestFieldNumber = 2,
    kGenPrepareMultichainProofRequestFieldNumber = 3,
    kGenAggregatedMultichainProofRequestFieldNumber = 4,
    kGenFinalMultichainProofRequestFieldNumber = 5,
    kCancelRequestFieldNumber = 6,
    kGetProofRequestFieldNumber = 7,
    kCalculateSha256RequestFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .multichain.v1.GetStatusRequest get_status_request = 2;
  bool has_get_status_request() const;
  private:
  bool _internal_has_get_status_request() const;
  public:
  void clear_get_status_request();
  const ::multichain::v1::GetStatusRequest& get_status_request() const;
  ::multichain::v1::GetStatusRequest* release_get_status_request();
  ::multichain::v1::GetStatusRequest* mutable_get_status_request();
  void set_allocated_get_status_request(::multichain::v1::GetStatusRequest* get_status_request);
  private:
  const ::multichain::v1::GetStatusRequest& _internal_get_status_request() const;
  ::multichain::v1::GetStatusRequest* _internal_mutable_get_status_request();
  public:
  void unsafe_arena_set_allocated_get_status_request(
      ::multichain::v1::GetStatusRequest* get_status_request);
  ::multichain::v1::GetStatusRequest* unsafe_arena_release_get_status_request();

  // .multichain.v1.GenPrepareMultichainProofRequest gen_prepare_multichain_proof_request = 3;
  bool has_gen_prepare_multichain_proof_request() const;
  private:
  bool _internal_has_gen_prepare_multichain_proof_request() const;
  public:
  void clear_gen_prepare_multichain_proof_request();
  const ::multichain::v1::GenPrepareMultichainProofRequest& gen_prepare_multichain_proof_request() const;
  ::multichain::v1::GenPrepareMultichainProofRequest* release_gen_prepare_multichain_proof_request();
  ::multichain::v1::GenPrepareMultichainProofRequest* mutable_gen_prepare_multichain_proof_request();
  void set_allocated_gen_prepare_multichain_proof_request(::multichain::v1::GenPrepareMultichainProofRequest* gen_prepare_multichain_proof_request);
  private:
  const ::multichain::v1::GenPrepareMultichainProofRequest& _internal_gen_prepare_multichain_proof_request() const;
  ::multichain::v1::GenPrepareMultichainProofRequest* _internal_mutable_gen_prepare_multichain_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_prepare_multichain_proof_request(
      ::multichain::v1::GenPrepareMultichainProofRequest* gen_prepare_multichain_proof_request);
  ::multichain::v1::GenPrepareMultichainProofRequest* unsafe_arena_release_gen_prepare_multichain_proof_request();

  // .multichain.v1.GenAggregatedMultichainProofRequest gen_aggregated_multichain_proof_request = 4;
  bool has_gen_aggregated_multichain_proof_request() const;
  private:
  bool _internal_has_gen_aggregated_multichain_proof_request() const;
  public:
  void clear_gen_aggregated_multichain_proof_request();
  const ::multichain::v1::GenAggregatedMultichainProofRequest& gen_aggregated_multichain_proof_request() const;
  ::multichain::v1::GenAggregatedMultichainProofRequest* release_gen_aggregated_multichain_proof_request();
  ::multichain::v1::GenAggregatedMultichainProofRequest* mutable_gen_aggregated_multichain_proof_request();
  void set_allocated_gen_aggregated_multichain_proof_request(::multichain::v1::GenAggregatedMultichainProofRequest* gen_aggregated_multichain_proof_request);
  private:
  const ::multichain::v1::GenAggregatedMultichainProofRequest& _internal_gen_aggregated_multichain_proof_request() const;
  ::multichain::v1::GenAggregatedMultichainProofRequest* _internal_mutable_gen_aggregated_multichain_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_aggregated_multichain_proof_request(
      ::multichain::v1::GenAggregatedMultichainProofRequest* gen_aggregated_multichain_proof_request);
  ::multichain::v1::GenAggregatedMultichainProofRequest* unsafe_arena_release_gen_aggregated_multichain_proof_request();

  // .multichain.v1.GenFinalMultichainProofRequest gen_final_multichain_proof_request = 5;
  bool has_gen_final_multichain_proof_request() const;
  private:
  bool _internal_has_gen_final_multichain_proof_request() const;
  public:
  void clear_gen_final_multichain_proof_request();
  const ::multichain::v1::GenFinalMultichainProofRequest& gen_final_multichain_proof_request() const;
  ::multichain::v1::GenFinalMultichainProofRequest* release_gen_final_multichain_proof_request();
  ::multichain::v1::GenFinalMultichainProofRequest* mutable_gen_final_multichain_proof_request();
  void set_allocated_gen_final_multichain_proof_request(::multichain::v1::GenFinalMultichainProofRequest* gen_final_multichain_proof_request);
  private:
  const ::multichain::v1::GenFinalMultichainProofRequest& _internal_gen_final_multichain_proof_request() const;
  ::multichain::v1::GenFinalMultichainProofRequest* _internal_mutable_gen_final_multichain_proof_request();
  public:
  void unsafe_arena_set_allocated_gen_final_multichain_proof_request(
      ::multichain::v1::GenFinalMultichainProofRequest* gen_final_multichain_proof_request);
  ::multichain::v1::GenFinalMultichainProofRequest* unsafe_arena_release_gen_final_multichain_proof_request();

  // .multichain.v1.CancelRequest cancel_request = 6;
  bool has_cancel_request() const;
  private:
  bool _internal_has_cancel_request() const;
  public:
  void clear_cancel_request();
  const ::multichain::v1::CancelRequest& cancel_request() const;
  ::multichain::v1::CancelRequest* release_cancel_request();
  ::multichain::v1::CancelRequest* mutable_cancel_request();
  void set_allocated_cancel_request(::multichain::v1::CancelRequest* cancel_request);
  private:
  const ::multichain::v1::CancelRequest& _internal_cancel_request() const;
  ::multichain::v1::CancelRequest* _internal_mutable_cancel_request();
  public:
  void unsafe_arena_set_allocated_cancel_request(
      ::multichain::v1::CancelRequest* cancel_request);
  ::multichain::v1::CancelRequest* unsafe_arena_release_cancel_request();

  // .multichain.v1.GetProofRequest get_proof_request = 7;
  bool has_get_proof_request() const;
  private:
  bool _internal_has_get_proof_request() const;
  public:
  void clear_get_proof_request();
  const ::multichain::v1::GetProofRequest& get_proof_request() const;
  ::multichain::v1::GetProofRequest* release_get_proof_request();
  ::multichain::v1::GetProofRequest* mutable_get_proof_request();
  void set_allocated_get_proof_request(::multichain::v1::GetProofRequest* get_proof_request);
  private:
  const ::multichain::v1::GetProofRequest& _internal_get_proof_request() const;
  ::multichain::v1::GetProofRequest* _internal_mutable_get_proof_request();
  public:
  void unsafe_arena_set_allocated_get_proof_request(
      ::multichain::v1::GetProofRequest* get_proof_request);
  ::multichain::v1::GetProofRequest* unsafe_arena_release_get_proof_request();

  // .multichain.v1.CalculateSha256Request calculate_sha256_request = 8;
  bool has_calculate_sha256_request() const;
  private:
  bool _internal_has_calculate_sha256_request() const;
  public:
  void clear_calculate_sha256_request();
  const ::multichain::v1::CalculateSha256Request& calculate_sha256_request() const;
  ::multichain::v1::CalculateSha256Request* release_calculate_sha256_request();
  ::multichain::v1::CalculateSha256Request* mutable_calculate_sha256_request();
  void set_allocated_calculate_sha256_request(::multichain::v1::CalculateSha256Request* calculate_sha256_request);
  private:
  const ::multichain::v1::CalculateSha256Request& _internal_calculate_sha256_request() const;
  ::multichain::v1::CalculateSha256Request* _internal_mutable_calculate_sha256_request();
  public:
  void unsafe_arena_set_allocated_calculate_sha256_request(
      ::multichain::v1::CalculateSha256Request* calculate_sha256_request);
  ::multichain::v1::CalculateSha256Request* unsafe_arena_release_calculate_sha256_request();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:multichain.v1.MultichainMessage)
 private:
  class _Internal;
  void set_has_get_status_request();
  void set_has_gen_prepare_multichain_proof_request();
  void set_has_gen_aggregated_multichain_proof_request();
  void set_has_gen_final_multichain_proof_request();
  void set_has_cancel_request();
  void set_has_get_proof_request();
  void set_has_calculate_sha256_request();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  union RequestUnion {
    RequestUnion() {}
    ::multichain::v1::GetStatusRequest* get_status_request_;
    ::multichain::v1::GenPrepareMultichainProofRequest* gen_prepare_multichain_proof_request_;
    ::multichain::v1::GenAggregatedMultichainProofRequest* gen_aggregated_multichain_proof_request_;
    ::multichain::v1::GenFinalMultichainProofRequest* gen_final_multichain_proof_request_;
    ::multichain::v1::CancelRequest* cancel_request_;
    ::multichain::v1::GetProofRequest* get_proof_request_;
    ::multichain::v1::CalculateSha256Request* calculate_sha256_request_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class ProverMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.ProverMessage) */ {
 public:
  inline ProverMessage() : ProverMessage(nullptr) {};
  virtual ~ProverMessage();

  ProverMessage(const ProverMessage& from);
  ProverMessage(ProverMessage&& from) noexcept
    : ProverMessage() {
    *this = ::std::move(from);
  }

  inline ProverMessage& operator=(const ProverMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProverMessage& operator=(ProverMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProverMessage& default_instance();

  enum ResponseCase {
    kGetStatusResponse = 2,
    kGenPrepareMultichainProofResponse = 3,
    kGenAggregatedMultichainProofResponse = 4,
    kGenFinalMultichainProofResponse = 5,
    kCancelResponse = 6,
    kGetProofResponse = 7,
    kCalculateSha256Response = 8,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProverMessage* internal_default_instance() {
    return reinterpret_cast<const ProverMessage*>(
               &_ProverMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ProverMessage& a, ProverMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProverMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProverMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProverMessage* New() const final {
    return CreateMaybeMessage<ProverMessage>(nullptr);
  }

  ProverMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProverMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProverMessage& from);
  void MergeFrom(const ProverMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProverMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.ProverMessage";
  }
  protected:
  explicit ProverMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kGetStatusResponseFieldNumber = 2,
    kGenPrepareMultichainProofResponseFieldNumber = 3,
    kGenAggregatedMultichainProofResponseFieldNumber = 4,
    kGenFinalMultichainProofResponseFieldNumber = 5,
    kCancelResponseFieldNumber = 6,
    kGetProofResponseFieldNumber = 7,
    kCalculateSha256ResponseFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .multichain.v1.GetStatusResponse get_status_response = 2;
  bool has_get_status_response() const;
  private:
  bool _internal_has_get_status_response() const;
  public:
  void clear_get_status_response();
  const ::multichain::v1::GetStatusResponse& get_status_response() const;
  ::multichain::v1::GetStatusResponse* release_get_status_response();
  ::multichain::v1::GetStatusResponse* mutable_get_status_response();
  void set_allocated_get_status_response(::multichain::v1::GetStatusResponse* get_status_response);
  private:
  const ::multichain::v1::GetStatusResponse& _internal_get_status_response() const;
  ::multichain::v1::GetStatusResponse* _internal_mutable_get_status_response();
  public:
  void unsafe_arena_set_allocated_get_status_response(
      ::multichain::v1::GetStatusResponse* get_status_response);
  ::multichain::v1::GetStatusResponse* unsafe_arena_release_get_status_response();

  // .multichain.v1.GenPrepareMultichainProofResponse gen_prepare_multichain_proof_response = 3;
  bool has_gen_prepare_multichain_proof_response() const;
  private:
  bool _internal_has_gen_prepare_multichain_proof_response() const;
  public:
  void clear_gen_prepare_multichain_proof_response();
  const ::multichain::v1::GenPrepareMultichainProofResponse& gen_prepare_multichain_proof_response() const;
  ::multichain::v1::GenPrepareMultichainProofResponse* release_gen_prepare_multichain_proof_response();
  ::multichain::v1::GenPrepareMultichainProofResponse* mutable_gen_prepare_multichain_proof_response();
  void set_allocated_gen_prepare_multichain_proof_response(::multichain::v1::GenPrepareMultichainProofResponse* gen_prepare_multichain_proof_response);
  private:
  const ::multichain::v1::GenPrepareMultichainProofResponse& _internal_gen_prepare_multichain_proof_response() const;
  ::multichain::v1::GenPrepareMultichainProofResponse* _internal_mutable_gen_prepare_multichain_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_prepare_multichain_proof_response(
      ::multichain::v1::GenPrepareMultichainProofResponse* gen_prepare_multichain_proof_response);
  ::multichain::v1::GenPrepareMultichainProofResponse* unsafe_arena_release_gen_prepare_multichain_proof_response();

  // .multichain.v1.GenAggregatedMultichainProofResponse gen_aggregated_multichain_proof_response = 4;
  bool has_gen_aggregated_multichain_proof_response() const;
  private:
  bool _internal_has_gen_aggregated_multichain_proof_response() const;
  public:
  void clear_gen_aggregated_multichain_proof_response();
  const ::multichain::v1::GenAggregatedMultichainProofResponse& gen_aggregated_multichain_proof_response() const;
  ::multichain::v1::GenAggregatedMultichainProofResponse* release_gen_aggregated_multichain_proof_response();
  ::multichain::v1::GenAggregatedMultichainProofResponse* mutable_gen_aggregated_multichain_proof_response();
  void set_allocated_gen_aggregated_multichain_proof_response(::multichain::v1::GenAggregatedMultichainProofResponse* gen_aggregated_multichain_proof_response);
  private:
  const ::multichain::v1::GenAggregatedMultichainProofResponse& _internal_gen_aggregated_multichain_proof_response() const;
  ::multichain::v1::GenAggregatedMultichainProofResponse* _internal_mutable_gen_aggregated_multichain_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_aggregated_multichain_proof_response(
      ::multichain::v1::GenAggregatedMultichainProofResponse* gen_aggregated_multichain_proof_response);
  ::multichain::v1::GenAggregatedMultichainProofResponse* unsafe_arena_release_gen_aggregated_multichain_proof_response();

  // .multichain.v1.GenFinalMultichainProofResponse gen_final_multichain_proof_response = 5;
  bool has_gen_final_multichain_proof_response() const;
  private:
  bool _internal_has_gen_final_multichain_proof_response() const;
  public:
  void clear_gen_final_multichain_proof_response();
  const ::multichain::v1::GenFinalMultichainProofResponse& gen_final_multichain_proof_response() const;
  ::multichain::v1::GenFinalMultichainProofResponse* release_gen_final_multichain_proof_response();
  ::multichain::v1::GenFinalMultichainProofResponse* mutable_gen_final_multichain_proof_response();
  void set_allocated_gen_final_multichain_proof_response(::multichain::v1::GenFinalMultichainProofResponse* gen_final_multichain_proof_response);
  private:
  const ::multichain::v1::GenFinalMultichainProofResponse& _internal_gen_final_multichain_proof_response() const;
  ::multichain::v1::GenFinalMultichainProofResponse* _internal_mutable_gen_final_multichain_proof_response();
  public:
  void unsafe_arena_set_allocated_gen_final_multichain_proof_response(
      ::multichain::v1::GenFinalMultichainProofResponse* gen_final_multichain_proof_response);
  ::multichain::v1::GenFinalMultichainProofResponse* unsafe_arena_release_gen_final_multichain_proof_response();

  // .multichain.v1.CancelResponse cancel_response = 6;
  bool has_cancel_response() const;
  private:
  bool _internal_has_cancel_response() const;
  public:
  void clear_cancel_response();
  const ::multichain::v1::CancelResponse& cancel_response() const;
  ::multichain::v1::CancelResponse* release_cancel_response();
  ::multichain::v1::CancelResponse* mutable_cancel_response();
  void set_allocated_cancel_response(::multichain::v1::CancelResponse* cancel_response);
  private:
  const ::multichain::v1::CancelResponse& _internal_cancel_response() const;
  ::multichain::v1::CancelResponse* _internal_mutable_cancel_response();
  public:
  void unsafe_arena_set_allocated_cancel_response(
      ::multichain::v1::CancelResponse* cancel_response);
  ::multichain::v1::CancelResponse* unsafe_arena_release_cancel_response();

  // .multichain.v1.GetProofResponse get_proof_response = 7;
  bool has_get_proof_response() const;
  private:
  bool _internal_has_get_proof_response() const;
  public:
  void clear_get_proof_response();
  const ::multichain::v1::GetProofResponse& get_proof_response() const;
  ::multichain::v1::GetProofResponse* release_get_proof_response();
  ::multichain::v1::GetProofResponse* mutable_get_proof_response();
  void set_allocated_get_proof_response(::multichain::v1::GetProofResponse* get_proof_response);
  private:
  const ::multichain::v1::GetProofResponse& _internal_get_proof_response() const;
  ::multichain::v1::GetProofResponse* _internal_mutable_get_proof_response();
  public:
  void unsafe_arena_set_allocated_get_proof_response(
      ::multichain::v1::GetProofResponse* get_proof_response);
  ::multichain::v1::GetProofResponse* unsafe_arena_release_get_proof_response();

  // .multichain.v1.CalculateSha256Response calculate_sha256_response = 8;
  bool has_calculate_sha256_response() const;
  private:
  bool _internal_has_calculate_sha256_response() const;
  public:
  void clear_calculate_sha256_response();
  const ::multichain::v1::CalculateSha256Response& calculate_sha256_response() const;
  ::multichain::v1::CalculateSha256Response* release_calculate_sha256_response();
  ::multichain::v1::CalculateSha256Response* mutable_calculate_sha256_response();
  void set_allocated_calculate_sha256_response(::multichain::v1::CalculateSha256Response* calculate_sha256_response);
  private:
  const ::multichain::v1::CalculateSha256Response& _internal_calculate_sha256_response() const;
  ::multichain::v1::CalculateSha256Response* _internal_mutable_calculate_sha256_response();
  public:
  void unsafe_arena_set_allocated_calculate_sha256_response(
      ::multichain::v1::CalculateSha256Response* calculate_sha256_response);
  ::multichain::v1::CalculateSha256Response* unsafe_arena_release_calculate_sha256_response();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:multichain.v1.ProverMessage)
 private:
  class _Internal;
  void set_has_get_status_response();
  void set_has_gen_prepare_multichain_proof_response();
  void set_has_gen_aggregated_multichain_proof_response();
  void set_has_gen_final_multichain_proof_response();
  void set_has_cancel_response();
  void set_has_get_proof_response();
  void set_has_calculate_sha256_response();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  union ResponseUnion {
    ResponseUnion() {}
    ::multichain::v1::GetStatusResponse* get_status_response_;
    ::multichain::v1::GenPrepareMultichainProofResponse* gen_prepare_multichain_proof_response_;
    ::multichain::v1::GenAggregatedMultichainProofResponse* gen_aggregated_multichain_proof_response_;
    ::multichain::v1::GenFinalMultichainProofResponse* gen_final_multichain_proof_response_;
    ::multichain::v1::CancelResponse* cancel_response_;
    ::multichain::v1::GetProofResponse* get_proof_response_;
    ::multichain::v1::CalculateSha256Response* calculate_sha256_response_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GetStatusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GetStatusRequest) */ {
 public:
  inline GetStatusRequest() : GetStatusRequest(nullptr) {};
  virtual ~GetStatusRequest();

  GetStatusRequest(const GetStatusRequest& from);
  GetStatusRequest(GetStatusRequest&& from) noexcept
    : GetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetStatusRequest& operator=(const GetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusRequest& operator=(GetStatusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetStatusRequest*>(
               &_GetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetStatusRequest& a, GetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusRequest* New() const final {
    return CreateMaybeMessage<GetStatusRequest>(nullptr);
  }

  GetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStatusRequest& from);
  void MergeFrom(const GetStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GetStatusRequest";
  }
  protected:
  explicit GetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:multichain.v1.GetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenPrepareMultichainProofRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenPrepareMultichainProofRequest) */ {
 public:
  inline GenPrepareMultichainProofRequest() : GenPrepareMultichainProofRequest(nullptr) {};
  virtual ~GenPrepareMultichainProofRequest();

  GenPrepareMultichainProofRequest(const GenPrepareMultichainProofRequest& from);
  GenPrepareMultichainProofRequest(GenPrepareMultichainProofRequest&& from) noexcept
    : GenPrepareMultichainProofRequest() {
    *this = ::std::move(from);
  }

  inline GenPrepareMultichainProofRequest& operator=(const GenPrepareMultichainProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenPrepareMultichainProofRequest& operator=(GenPrepareMultichainProofRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenPrepareMultichainProofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenPrepareMultichainProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenPrepareMultichainProofRequest*>(
               &_GenPrepareMultichainProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GenPrepareMultichainProofRequest& a, GenPrepareMultichainProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenPrepareMultichainProofRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenPrepareMultichainProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenPrepareMultichainProofRequest* New() const final {
    return CreateMaybeMessage<GenPrepareMultichainProofRequest>(nullptr);
  }

  GenPrepareMultichainProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenPrepareMultichainProofRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenPrepareMultichainProofRequest& from);
  void MergeFrom(const GenPrepareMultichainProofRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenPrepareMultichainProofRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenPrepareMultichainProofRequest";
  }
  protected:
  explicit GenPrepareMultichainProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecursiveProofFieldNumber = 1,
    kPreviousHashFieldNumber = 2,
  };
  // string recursive_proof = 1;
  void clear_recursive_proof();
  const std::string& recursive_proof() const;
  void set_recursive_proof(const std::string& value);
  void set_recursive_proof(std::string&& value);
  void set_recursive_proof(const char* value);
  void set_recursive_proof(const char* value, size_t size);
  std::string* mutable_recursive_proof();
  std::string* release_recursive_proof();
  void set_allocated_recursive_proof(std::string* recursive_proof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_recursive_proof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_recursive_proof(
      std::string* recursive_proof);
  private:
  const std::string& _internal_recursive_proof() const;
  void _internal_set_recursive_proof(const std::string& value);
  std::string* _internal_mutable_recursive_proof();
  public:

  // string previous_hash = 2;
  void clear_previous_hash();
  const std::string& previous_hash() const;
  void set_previous_hash(const std::string& value);
  void set_previous_hash(std::string&& value);
  void set_previous_hash(const char* value);
  void set_previous_hash(const char* value, size_t size);
  std::string* mutable_previous_hash();
  std::string* release_previous_hash();
  void set_allocated_previous_hash(std::string* previous_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_previous_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_previous_hash(
      std::string* previous_hash);
  private:
  const std::string& _internal_previous_hash() const;
  void _internal_set_previous_hash(const std::string& value);
  std::string* _internal_mutable_previous_hash();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenPrepareMultichainProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recursive_proof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedMultichainProofRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenAggregatedMultichainProofRequest) */ {
 public:
  inline GenAggregatedMultichainProofRequest() : GenAggregatedMultichainProofRequest(nullptr) {};
  virtual ~GenAggregatedMultichainProofRequest();

  GenAggregatedMultichainProofRequest(const GenAggregatedMultichainProofRequest& from);
  GenAggregatedMultichainProofRequest(GenAggregatedMultichainProofRequest&& from) noexcept
    : GenAggregatedMultichainProofRequest() {
    *this = ::std::move(from);
  }

  inline GenAggregatedMultichainProofRequest& operator=(const GenAggregatedMultichainProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedMultichainProofRequest& operator=(GenAggregatedMultichainProofRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenAggregatedMultichainProofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenAggregatedMultichainProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedMultichainProofRequest*>(
               &_GenAggregatedMultichainProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GenAggregatedMultichainProofRequest& a, GenAggregatedMultichainProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenAggregatedMultichainProofRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedMultichainProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenAggregatedMultichainProofRequest* New() const final {
    return CreateMaybeMessage<GenAggregatedMultichainProofRequest>(nullptr);
  }

  GenAggregatedMultichainProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenAggregatedMultichainProofRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenAggregatedMultichainProofRequest& from);
  void MergeFrom(const GenAggregatedMultichainProofRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenAggregatedMultichainProofRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenAggregatedMultichainProofRequest";
  }
  protected:
  explicit GenAggregatedMultichainProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultichainProof1FieldNumber = 1,
    kMultichainProof2FieldNumber = 2,
  };
  // string multichain_proof_1 = 1;
  void clear_multichain_proof_1();
  const std::string& multichain_proof_1() const;
  void set_multichain_proof_1(const std::string& value);
  void set_multichain_proof_1(std::string&& value);
  void set_multichain_proof_1(const char* value);
  void set_multichain_proof_1(const char* value, size_t size);
  std::string* mutable_multichain_proof_1();
  std::string* release_multichain_proof_1();
  void set_allocated_multichain_proof_1(std::string* multichain_proof_1);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_multichain_proof_1();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_multichain_proof_1(
      std::string* multichain_proof_1);
  private:
  const std::string& _internal_multichain_proof_1() const;
  void _internal_set_multichain_proof_1(const std::string& value);
  std::string* _internal_mutable_multichain_proof_1();
  public:

  // string multichain_proof_2 = 2;
  void clear_multichain_proof_2();
  const std::string& multichain_proof_2() const;
  void set_multichain_proof_2(const std::string& value);
  void set_multichain_proof_2(std::string&& value);
  void set_multichain_proof_2(const char* value);
  void set_multichain_proof_2(const char* value, size_t size);
  std::string* mutable_multichain_proof_2();
  std::string* release_multichain_proof_2();
  void set_allocated_multichain_proof_2(std::string* multichain_proof_2);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_multichain_proof_2();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_multichain_proof_2(
      std::string* multichain_proof_2);
  private:
  const std::string& _internal_multichain_proof_2() const;
  void _internal_set_multichain_proof_2(const std::string& value);
  std::string* _internal_mutable_multichain_proof_2();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenAggregatedMultichainProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multichain_proof_1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multichain_proof_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenFinalMultichainProofRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenFinalMultichainProofRequest) */ {
 public:
  inline GenFinalMultichainProofRequest() : GenFinalMultichainProofRequest(nullptr) {};
  virtual ~GenFinalMultichainProofRequest();

  GenFinalMultichainProofRequest(const GenFinalMultichainProofRequest& from);
  GenFinalMultichainProofRequest(GenFinalMultichainProofRequest&& from) noexcept
    : GenFinalMultichainProofRequest() {
    *this = ::std::move(from);
  }

  inline GenFinalMultichainProofRequest& operator=(const GenFinalMultichainProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalMultichainProofRequest& operator=(GenFinalMultichainProofRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenFinalMultichainProofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenFinalMultichainProofRequest* internal_default_instance() {
    return reinterpret_cast<const GenFinalMultichainProofRequest*>(
               &_GenFinalMultichainProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenFinalMultichainProofRequest& a, GenFinalMultichainProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenFinalMultichainProofRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalMultichainProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenFinalMultichainProofRequest* New() const final {
    return CreateMaybeMessage<GenFinalMultichainProofRequest>(nullptr);
  }

  GenFinalMultichainProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenFinalMultichainProofRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenFinalMultichainProofRequest& from);
  void MergeFrom(const GenFinalMultichainProofRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenFinalMultichainProofRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenFinalMultichainProofRequest";
  }
  protected:
  explicit GenFinalMultichainProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultichainProofFieldNumber = 1,
    kAggregatorAddrFieldNumber = 2,
  };
  // string multichain_proof = 1;
  void clear_multichain_proof();
  const std::string& multichain_proof() const;
  void set_multichain_proof(const std::string& value);
  void set_multichain_proof(std::string&& value);
  void set_multichain_proof(const char* value);
  void set_multichain_proof(const char* value, size_t size);
  std::string* mutable_multichain_proof();
  std::string* release_multichain_proof();
  void set_allocated_multichain_proof(std::string* multichain_proof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_multichain_proof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_multichain_proof(
      std::string* multichain_proof);
  private:
  const std::string& _internal_multichain_proof() const;
  void _internal_set_multichain_proof(const std::string& value);
  std::string* _internal_mutable_multichain_proof();
  public:

  // string aggregator_addr = 2;
  void clear_aggregator_addr();
  const std::string& aggregator_addr() const;
  void set_aggregator_addr(const std::string& value);
  void set_aggregator_addr(std::string&& value);
  void set_aggregator_addr(const char* value);
  void set_aggregator_addr(const char* value, size_t size);
  std::string* mutable_aggregator_addr();
  std::string* release_aggregator_addr();
  void set_allocated_aggregator_addr(std::string* aggregator_addr);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_aggregator_addr();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_aggregator_addr(
      std::string* aggregator_addr);
  private:
  const std::string& _internal_aggregator_addr() const;
  void _internal_set_aggregator_addr(const std::string& value);
  std::string* _internal_mutable_aggregator_addr();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenFinalMultichainProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multichain_proof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregator_addr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class CancelRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.CancelRequest) */ {
 public:
  inline CancelRequest() : CancelRequest(nullptr) {};
  virtual ~CancelRequest();

  CancelRequest(const CancelRequest& from);
  CancelRequest(CancelRequest&& from) noexcept
    : CancelRequest() {
    *this = ::std::move(from);
  }

  inline CancelRequest& operator=(const CancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelRequest& operator=(CancelRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelRequest* internal_default_instance() {
    return reinterpret_cast<const CancelRequest*>(
               &_CancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CancelRequest& a, CancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelRequest* New() const final {
    return CreateMaybeMessage<CancelRequest>(nullptr);
  }

  CancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelRequest& from);
  void MergeFrom(const CancelRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.CancelRequest";
  }
  protected:
  explicit CancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.CancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GetProofRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GetProofRequest) */ {
 public:
  inline GetProofRequest() : GetProofRequest(nullptr) {};
  virtual ~GetProofRequest();

  GetProofRequest(const GetProofRequest& from);
  GetProofRequest(GetProofRequest&& from) noexcept
    : GetProofRequest() {
    *this = ::std::move(from);
  }

  inline GetProofRequest& operator=(const GetProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofRequest& operator=(GetProofRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProofRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProofRequest* internal_default_instance() {
    return reinterpret_cast<const GetProofRequest*>(
               &_GetProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetProofRequest& a, GetProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProofRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProofRequest* New() const final {
    return CreateMaybeMessage<GetProofRequest>(nullptr);
  }

  GetProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProofRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProofRequest& from);
  void MergeFrom(const GetProofRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProofRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GetProofRequest";
  }
  protected:
  explicit GetProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTimeoutFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // uint64 timeout = 2;
  void clear_timeout();
  ::PROTOBUF_NAMESPACE_ID::uint64 timeout() const;
  void set_timeout(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timeout() const;
  void _internal_set_timeout(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GetProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class CalculateSha256Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.CalculateSha256Request) */ {
 public:
  inline CalculateSha256Request() : CalculateSha256Request(nullptr) {};
  virtual ~CalculateSha256Request();

  CalculateSha256Request(const CalculateSha256Request& from);
  CalculateSha256Request(CalculateSha256Request&& from) noexcept
    : CalculateSha256Request() {
    *this = ::std::move(from);
  }

  inline CalculateSha256Request& operator=(const CalculateSha256Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalculateSha256Request& operator=(CalculateSha256Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CalculateSha256Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalculateSha256Request* internal_default_instance() {
    return reinterpret_cast<const CalculateSha256Request*>(
               &_CalculateSha256Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CalculateSha256Request& a, CalculateSha256Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CalculateSha256Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CalculateSha256Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CalculateSha256Request* New() const final {
    return CreateMaybeMessage<CalculateSha256Request>(nullptr);
  }

  CalculateSha256Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalculateSha256Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalculateSha256Request& from);
  void MergeFrom(const CalculateSha256Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalculateSha256Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.CalculateSha256Request";
  }
  protected:
  explicit CalculateSha256Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicsFieldNumber = 1,
    kPreviousHashFieldNumber = 2,
  };
  // string publics = 1;
  void clear_publics();
  const std::string& publics() const;
  void set_publics(const std::string& value);
  void set_publics(std::string&& value);
  void set_publics(const char* value);
  void set_publics(const char* value, size_t size);
  std::string* mutable_publics();
  std::string* release_publics();
  void set_allocated_publics(std::string* publics);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_publics();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_publics(
      std::string* publics);
  private:
  const std::string& _internal_publics() const;
  void _internal_set_publics(const std::string& value);
  std::string* _internal_mutable_publics();
  public:

  // string previous_hash = 2;
  void clear_previous_hash();
  const std::string& previous_hash() const;
  void set_previous_hash(const std::string& value);
  void set_previous_hash(std::string&& value);
  void set_previous_hash(const char* value);
  void set_previous_hash(const char* value, size_t size);
  std::string* mutable_previous_hash();
  std::string* release_previous_hash();
  void set_allocated_previous_hash(std::string* previous_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_previous_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_previous_hash(
      std::string* previous_hash);
  private:
  const std::string& _internal_previous_hash() const;
  void _internal_set_previous_hash(const std::string& value);
  std::string* _internal_mutable_previous_hash();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.CalculateSha256Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GetStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GetStatusResponse) */ {
 public:
  inline GetStatusResponse() : GetStatusResponse(nullptr) {};
  virtual ~GetStatusResponse();

  GetStatusResponse(const GetStatusResponse& from);
  GetStatusResponse(GetStatusResponse&& from) noexcept
    : GetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GetStatusResponse& operator=(const GetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStatusResponse& operator=(GetStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GetStatusResponse*>(
               &_GetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetStatusResponse& a, GetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetStatusResponse* New() const final {
    return CreateMaybeMessage<GetStatusResponse>(nullptr);
  }

  GetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetStatusResponse& from);
  void MergeFrom(const GetStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GetStatusResponse";
  }
  protected:
  explicit GetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GetStatusResponse_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    GetStatusResponse_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_BOOTING =
    GetStatusResponse_Status_STATUS_BOOTING;
  static constexpr Status STATUS_COMPUTING =
    GetStatusResponse_Status_STATUS_COMPUTING;
  static constexpr Status STATUS_IDLE =
    GetStatusResponse_Status_STATUS_IDLE;
  static constexpr Status STATUS_HALT =
    GetStatusResponse_Status_STATUS_HALT;
  static inline bool Status_IsValid(int value) {
    return GetStatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    GetStatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    GetStatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    GetStatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return GetStatusResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return GetStatusResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(const std::string& name,
      Status* value) {
    return GetStatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPendingRequestQueueIdsFieldNumber = 8,
    kLastComputedRequestIdFieldNumber = 2,
    kCurrentComputingRequestIdFieldNumber = 4,
    kVersionProtoFieldNumber = 6,
    kVersionServerFieldNumber = 7,
    kProverNameFieldNumber = 9,
    kProverIdFieldNumber = 10,
    kLastComputedEndTimeFieldNumber = 3,
    kCurrentComputingStartTimeFieldNumber = 5,
    kNumberOfCoresFieldNumber = 11,
    kTotalMemoryFieldNumber = 12,
    kFreeMemoryFieldNumber = 13,
    kForkIdFieldNumber = 14,
    kStatusFieldNumber = 1,
  };
  // repeated string pending_request_queue_ids = 8;
  int pending_request_queue_ids_size() const;
  private:
  int _internal_pending_request_queue_ids_size() const;
  public:
  void clear_pending_request_queue_ids();
  const std::string& pending_request_queue_ids(int index) const;
  std::string* mutable_pending_request_queue_ids(int index);
  void set_pending_request_queue_ids(int index, const std::string& value);
  void set_pending_request_queue_ids(int index, std::string&& value);
  void set_pending_request_queue_ids(int index, const char* value);
  void set_pending_request_queue_ids(int index, const char* value, size_t size);
  std::string* add_pending_request_queue_ids();
  void add_pending_request_queue_ids(const std::string& value);
  void add_pending_request_queue_ids(std::string&& value);
  void add_pending_request_queue_ids(const char* value);
  void add_pending_request_queue_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& pending_request_queue_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_pending_request_queue_ids();
  private:
  const std::string& _internal_pending_request_queue_ids(int index) const;
  std::string* _internal_add_pending_request_queue_ids();
  public:

  // string last_computed_request_id = 2;
  void clear_last_computed_request_id();
  const std::string& last_computed_request_id() const;
  void set_last_computed_request_id(const std::string& value);
  void set_last_computed_request_id(std::string&& value);
  void set_last_computed_request_id(const char* value);
  void set_last_computed_request_id(const char* value, size_t size);
  std::string* mutable_last_computed_request_id();
  std::string* release_last_computed_request_id();
  void set_allocated_last_computed_request_id(std::string* last_computed_request_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_last_computed_request_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_last_computed_request_id(
      std::string* last_computed_request_id);
  private:
  const std::string& _internal_last_computed_request_id() const;
  void _internal_set_last_computed_request_id(const std::string& value);
  std::string* _internal_mutable_last_computed_request_id();
  public:

  // string current_computing_request_id = 4;
  void clear_current_computing_request_id();
  const std::string& current_computing_request_id() const;
  void set_current_computing_request_id(const std::string& value);
  void set_current_computing_request_id(std::string&& value);
  void set_current_computing_request_id(const char* value);
  void set_current_computing_request_id(const char* value, size_t size);
  std::string* mutable_current_computing_request_id();
  std::string* release_current_computing_request_id();
  void set_allocated_current_computing_request_id(std::string* current_computing_request_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_current_computing_request_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_current_computing_request_id(
      std::string* current_computing_request_id);
  private:
  const std::string& _internal_current_computing_request_id() const;
  void _internal_set_current_computing_request_id(const std::string& value);
  std::string* _internal_mutable_current_computing_request_id();
  public:

  // string version_proto = 6;
  void clear_version_proto();
  const std::string& version_proto() const;
  void set_version_proto(const std::string& value);
  void set_version_proto(std::string&& value);
  void set_version_proto(const char* value);
  void set_version_proto(const char* value, size_t size);
  std::string* mutable_version_proto();
  std::string* release_version_proto();
  void set_allocated_version_proto(std::string* version_proto);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version_proto();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version_proto(
      std::string* version_proto);
  private:
  const std::string& _internal_version_proto() const;
  void _internal_set_version_proto(const std::string& value);
  std::string* _internal_mutable_version_proto();
  public:

  // string version_server = 7;
  void clear_version_server();
  const std::string& version_server() const;
  void set_version_server(const std::string& value);
  void set_version_server(std::string&& value);
  void set_version_server(const char* value);
  void set_version_server(const char* value, size_t size);
  std::string* mutable_version_server();
  std::string* release_version_server();
  void set_allocated_version_server(std::string* version_server);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_version_server();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_version_server(
      std::string* version_server);
  private:
  const std::string& _internal_version_server() const;
  void _internal_set_version_server(const std::string& value);
  std::string* _internal_mutable_version_server();
  public:

  // string prover_name = 9;
  void clear_prover_name();
  const std::string& prover_name() const;
  void set_prover_name(const std::string& value);
  void set_prover_name(std::string&& value);
  void set_prover_name(const char* value);
  void set_prover_name(const char* value, size_t size);
  std::string* mutable_prover_name();
  std::string* release_prover_name();
  void set_allocated_prover_name(std::string* prover_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prover_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prover_name(
      std::string* prover_name);
  private:
  const std::string& _internal_prover_name() const;
  void _internal_set_prover_name(const std::string& value);
  std::string* _internal_mutable_prover_name();
  public:

  // string prover_id = 10;
  void clear_prover_id();
  const std::string& prover_id() const;
  void set_prover_id(const std::string& value);
  void set_prover_id(std::string&& value);
  void set_prover_id(const char* value);
  void set_prover_id(const char* value, size_t size);
  std::string* mutable_prover_id();
  std::string* release_prover_id();
  void set_allocated_prover_id(std::string* prover_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_prover_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_prover_id(
      std::string* prover_id);
  private:
  const std::string& _internal_prover_id() const;
  void _internal_set_prover_id(const std::string& value);
  std::string* _internal_mutable_prover_id();
  public:

  // uint64 last_computed_end_time = 3;
  void clear_last_computed_end_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_computed_end_time() const;
  void set_last_computed_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_last_computed_end_time() const;
  void _internal_set_last_computed_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 current_computing_start_time = 5;
  void clear_current_computing_start_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 current_computing_start_time() const;
  void set_current_computing_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_current_computing_start_time() const;
  void _internal_set_current_computing_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 number_of_cores = 11;
  void clear_number_of_cores();
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_cores() const;
  void set_number_of_cores(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_number_of_cores() const;
  void _internal_set_number_of_cores(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 total_memory = 12;
  void clear_total_memory();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_memory() const;
  void set_total_memory(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_memory() const;
  void _internal_set_total_memory(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 free_memory = 13;
  void clear_free_memory();
  ::PROTOBUF_NAMESPACE_ID::uint64 free_memory() const;
  void set_free_memory(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_free_memory() const;
  void _internal_set_free_memory(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 fork_id = 14;
  void clear_fork_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 fork_id() const;
  void set_fork_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fork_id() const;
  void _internal_set_fork_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .multichain.v1.GetStatusResponse.Status status = 1;
  void clear_status();
  ::multichain::v1::GetStatusResponse_Status status() const;
  void set_status(::multichain::v1::GetStatusResponse_Status value);
  private:
  ::multichain::v1::GetStatusResponse_Status _internal_status() const;
  void _internal_set_status(::multichain::v1::GetStatusResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> pending_request_queue_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_computed_request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_computing_request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_proto_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_computed_end_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 current_computing_start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_cores_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_memory_;
  ::PROTOBUF_NAMESPACE_ID::uint64 free_memory_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fork_id_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenPrepareMultichainProofResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenPrepareMultichainProofResponse) */ {
 public:
  inline GenPrepareMultichainProofResponse() : GenPrepareMultichainProofResponse(nullptr) {};
  virtual ~GenPrepareMultichainProofResponse();

  GenPrepareMultichainProofResponse(const GenPrepareMultichainProofResponse& from);
  GenPrepareMultichainProofResponse(GenPrepareMultichainProofResponse&& from) noexcept
    : GenPrepareMultichainProofResponse() {
    *this = ::std::move(from);
  }

  inline GenPrepareMultichainProofResponse& operator=(const GenPrepareMultichainProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenPrepareMultichainProofResponse& operator=(GenPrepareMultichainProofResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenPrepareMultichainProofResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenPrepareMultichainProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenPrepareMultichainProofResponse*>(
               &_GenPrepareMultichainProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GenPrepareMultichainProofResponse& a, GenPrepareMultichainProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenPrepareMultichainProofResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenPrepareMultichainProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenPrepareMultichainProofResponse* New() const final {
    return CreateMaybeMessage<GenPrepareMultichainProofResponse>(nullptr);
  }

  GenPrepareMultichainProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenPrepareMultichainProofResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenPrepareMultichainProofResponse& from);
  void MergeFrom(const GenPrepareMultichainProofResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenPrepareMultichainProofResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenPrepareMultichainProofResponse";
  }
  protected:
  explicit GenPrepareMultichainProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .multichain.v1.Result result = 2;
  void clear_result();
  ::multichain::v1::Result result() const;
  void set_result(::multichain::v1::Result value);
  private:
  ::multichain::v1::Result _internal_result() const;
  void _internal_set_result(::multichain::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenPrepareMultichainProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenAggregatedMultichainProofResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenAggregatedMultichainProofResponse) */ {
 public:
  inline GenAggregatedMultichainProofResponse() : GenAggregatedMultichainProofResponse(nullptr) {};
  virtual ~GenAggregatedMultichainProofResponse();

  GenAggregatedMultichainProofResponse(const GenAggregatedMultichainProofResponse& from);
  GenAggregatedMultichainProofResponse(GenAggregatedMultichainProofResponse&& from) noexcept
    : GenAggregatedMultichainProofResponse() {
    *this = ::std::move(from);
  }

  inline GenAggregatedMultichainProofResponse& operator=(const GenAggregatedMultichainProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenAggregatedMultichainProofResponse& operator=(GenAggregatedMultichainProofResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenAggregatedMultichainProofResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenAggregatedMultichainProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenAggregatedMultichainProofResponse*>(
               &_GenAggregatedMultichainProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GenAggregatedMultichainProofResponse& a, GenAggregatedMultichainProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenAggregatedMultichainProofResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenAggregatedMultichainProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenAggregatedMultichainProofResponse* New() const final {
    return CreateMaybeMessage<GenAggregatedMultichainProofResponse>(nullptr);
  }

  GenAggregatedMultichainProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenAggregatedMultichainProofResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenAggregatedMultichainProofResponse& from);
  void MergeFrom(const GenAggregatedMultichainProofResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenAggregatedMultichainProofResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenAggregatedMultichainProofResponse";
  }
  protected:
  explicit GenAggregatedMultichainProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .multichain.v1.Result result = 2;
  void clear_result();
  ::multichain::v1::Result result() const;
  void set_result(::multichain::v1::Result value);
  private:
  ::multichain::v1::Result _internal_result() const;
  void _internal_set_result(::multichain::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenAggregatedMultichainProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GenFinalMultichainProofResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GenFinalMultichainProofResponse) */ {
 public:
  inline GenFinalMultichainProofResponse() : GenFinalMultichainProofResponse(nullptr) {};
  virtual ~GenFinalMultichainProofResponse();

  GenFinalMultichainProofResponse(const GenFinalMultichainProofResponse& from);
  GenFinalMultichainProofResponse(GenFinalMultichainProofResponse&& from) noexcept
    : GenFinalMultichainProofResponse() {
    *this = ::std::move(from);
  }

  inline GenFinalMultichainProofResponse& operator=(const GenFinalMultichainProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenFinalMultichainProofResponse& operator=(GenFinalMultichainProofResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenFinalMultichainProofResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenFinalMultichainProofResponse* internal_default_instance() {
    return reinterpret_cast<const GenFinalMultichainProofResponse*>(
               &_GenFinalMultichainProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GenFinalMultichainProofResponse& a, GenFinalMultichainProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenFinalMultichainProofResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenFinalMultichainProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenFinalMultichainProofResponse* New() const final {
    return CreateMaybeMessage<GenFinalMultichainProofResponse>(nullptr);
  }

  GenFinalMultichainProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenFinalMultichainProofResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenFinalMultichainProofResponse& from);
  void MergeFrom(const GenFinalMultichainProofResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenFinalMultichainProofResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GenFinalMultichainProofResponse";
  }
  protected:
  explicit GenFinalMultichainProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .multichain.v1.Result result = 2;
  void clear_result();
  ::multichain::v1::Result result() const;
  void set_result(::multichain::v1::Result value);
  private:
  ::multichain::v1::Result _internal_result() const;
  void _internal_set_result(::multichain::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.GenFinalMultichainProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class CancelResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.CancelResponse) */ {
 public:
  inline CancelResponse() : CancelResponse(nullptr) {};
  virtual ~CancelResponse();

  CancelResponse(const CancelResponse& from);
  CancelResponse(CancelResponse&& from) noexcept
    : CancelResponse() {
    *this = ::std::move(from);
  }

  inline CancelResponse& operator=(const CancelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelResponse& operator=(CancelResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CancelResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelResponse* internal_default_instance() {
    return reinterpret_cast<const CancelResponse*>(
               &_CancelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CancelResponse& a, CancelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CancelResponse* New() const final {
    return CreateMaybeMessage<CancelResponse>(nullptr);
  }

  CancelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CancelResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CancelResponse& from);
  void MergeFrom(const CancelResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.CancelResponse";
  }
  protected:
  explicit CancelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .multichain.v1.Result result = 1;
  void clear_result();
  ::multichain::v1::Result result() const;
  void set_result(::multichain::v1::Result value);
  private:
  ::multichain::v1::Result _internal_result() const;
  void _internal_set_result(::multichain::v1::Result value);
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.CancelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class GetProofResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.GetProofResponse) */ {
 public:
  inline GetProofResponse() : GetProofResponse(nullptr) {};
  virtual ~GetProofResponse();

  GetProofResponse(const GetProofResponse& from);
  GetProofResponse(GetProofResponse&& from) noexcept
    : GetProofResponse() {
    *this = ::std::move(from);
  }

  inline GetProofResponse& operator=(const GetProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetProofResponse& operator=(GetProofResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetProofResponse& default_instance();

  enum ProofCase {
    kPrepareProof = 2,
    kMultichainProof = 3,
    PROOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetProofResponse* internal_default_instance() {
    return reinterpret_cast<const GetProofResponse*>(
               &_GetProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetProofResponse& a, GetProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetProofResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetProofResponse* New() const final {
    return CreateMaybeMessage<GetProofResponse>(nullptr);
  }

  GetProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetProofResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetProofResponse& from);
  void MergeFrom(const GetProofResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetProofResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.GetProofResponse";
  }
  protected:
  explicit GetProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GetProofResponse_Result Result;
  static constexpr Result RESULT_UNSPECIFIED =
    GetProofResponse_Result_RESULT_UNSPECIFIED;
  static constexpr Result RESULT_COMPLETED_OK =
    GetProofResponse_Result_RESULT_COMPLETED_OK;
  static constexpr Result RESULT_ERROR =
    GetProofResponse_Result_RESULT_ERROR;
  static constexpr Result RESULT_COMPLETED_ERROR =
    GetProofResponse_Result_RESULT_COMPLETED_ERROR;
  static constexpr Result RESULT_PENDING =
    GetProofResponse_Result_RESULT_PENDING;
  static constexpr Result RESULT_INTERNAL_ERROR =
    GetProofResponse_Result_RESULT_INTERNAL_ERROR;
  static constexpr Result RESULT_CANCEL =
    GetProofResponse_Result_RESULT_CANCEL;
  static inline bool Result_IsValid(int value) {
    return GetProofResponse_Result_IsValid(value);
  }
  static constexpr Result Result_MIN =
    GetProofResponse_Result_Result_MIN;
  static constexpr Result Result_MAX =
    GetProofResponse_Result_Result_MAX;
  static constexpr int Result_ARRAYSIZE =
    GetProofResponse_Result_Result_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Result_descriptor() {
    return GetProofResponse_Result_descriptor();
  }
  template<typename T>
  static inline const std::string& Result_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Result>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Result_Name.");
    return GetProofResponse_Result_Name(enum_t_value);
  }
  static inline bool Result_Parse(const std::string& name,
      Result* value) {
    return GetProofResponse_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kResultStringFieldNumber = 5,
    kResultFieldNumber = 4,
    kPrepareProofFieldNumber = 2,
    kMultichainProofFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string result_string = 5;
  void clear_result_string();
  const std::string& result_string() const;
  void set_result_string(const std::string& value);
  void set_result_string(std::string&& value);
  void set_result_string(const char* value);
  void set_result_string(const char* value, size_t size);
  std::string* mutable_result_string();
  std::string* release_result_string();
  void set_allocated_result_string(std::string* result_string);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_result_string();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_result_string(
      std::string* result_string);
  private:
  const std::string& _internal_result_string() const;
  void _internal_set_result_string(const std::string& value);
  std::string* _internal_mutable_result_string();
  public:

  // .multichain.v1.GetProofResponse.Result result = 4;
  void clear_result();
  ::multichain::v1::GetProofResponse_Result result() const;
  void set_result(::multichain::v1::GetProofResponse_Result value);
  private:
  ::multichain::v1::GetProofResponse_Result _internal_result() const;
  void _internal_set_result(::multichain::v1::GetProofResponse_Result value);
  public:

  // .multichain.v1.PrepareProof prepare_proof = 2;
  bool has_prepare_proof() const;
  private:
  bool _internal_has_prepare_proof() const;
  public:
  void clear_prepare_proof();
  const ::multichain::v1::PrepareProof& prepare_proof() const;
  ::multichain::v1::PrepareProof* release_prepare_proof();
  ::multichain::v1::PrepareProof* mutable_prepare_proof();
  void set_allocated_prepare_proof(::multichain::v1::PrepareProof* prepare_proof);
  private:
  const ::multichain::v1::PrepareProof& _internal_prepare_proof() const;
  ::multichain::v1::PrepareProof* _internal_mutable_prepare_proof();
  public:
  void unsafe_arena_set_allocated_prepare_proof(
      ::multichain::v1::PrepareProof* prepare_proof);
  ::multichain::v1::PrepareProof* unsafe_arena_release_prepare_proof();

  // string multichain_proof = 3;
  private:
  bool _internal_has_multichain_proof() const;
  public:
  void clear_multichain_proof();
  const std::string& multichain_proof() const;
  void set_multichain_proof(const std::string& value);
  void set_multichain_proof(std::string&& value);
  void set_multichain_proof(const char* value);
  void set_multichain_proof(const char* value, size_t size);
  std::string* mutable_multichain_proof();
  std::string* release_multichain_proof();
  void set_allocated_multichain_proof(std::string* multichain_proof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_multichain_proof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_multichain_proof(
      std::string* multichain_proof);
  private:
  const std::string& _internal_multichain_proof() const;
  void _internal_set_multichain_proof(const std::string& value);
  std::string* _internal_mutable_multichain_proof();
  public:

  void clear_proof();
  ProofCase proof_case() const;
  // @@protoc_insertion_point(class_scope:multichain.v1.GetProofResponse)
 private:
  class _Internal;
  void set_has_prepare_proof();
  void set_has_multichain_proof();

  inline bool has_proof() const;
  inline void clear_has_proof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_string_;
  int result_;
  union ProofUnion {
    ProofUnion() {}
    ::multichain::v1::PrepareProof* prepare_proof_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr multichain_proof_;
  } proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class PrepareProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.PrepareProof) */ {
 public:
  inline PrepareProof() : PrepareProof(nullptr) {};
  virtual ~PrepareProof();

  PrepareProof(const PrepareProof& from);
  PrepareProof(PrepareProof&& from) noexcept
    : PrepareProof() {
    *this = ::std::move(from);
  }

  inline PrepareProof& operator=(const PrepareProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareProof& operator=(PrepareProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrepareProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareProof* internal_default_instance() {
    return reinterpret_cast<const PrepareProof*>(
               &_PrepareProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PrepareProof& a, PrepareProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrepareProof* New() const final {
    return CreateMaybeMessage<PrepareProof>(nullptr);
  }

  PrepareProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrepareProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrepareProof& from);
  void MergeFrom(const PrepareProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.PrepareProof";
  }
  protected:
  explicit PrepareProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 1,
    kHashInfoFieldNumber = 2,
  };
  // string proof = 1;
  void clear_proof();
  const std::string& proof() const;
  void set_proof(const std::string& value);
  void set_proof(std::string&& value);
  void set_proof(const char* value);
  void set_proof(const char* value, size_t size);
  std::string* mutable_proof();
  std::string* release_proof();
  void set_allocated_proof(std::string* proof);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_proof();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_proof(
      std::string* proof);
  private:
  const std::string& _internal_proof() const;
  void _internal_set_proof(const std::string& value);
  std::string* _internal_mutable_proof();
  public:

  // string hash_info = 2;
  void clear_hash_info();
  const std::string& hash_info() const;
  void set_hash_info(const std::string& value);
  void set_hash_info(std::string&& value);
  void set_hash_info(const char* value);
  void set_hash_info(const char* value, size_t size);
  std::string* mutable_hash_info();
  std::string* release_hash_info();
  void set_allocated_hash_info(std::string* hash_info);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash_info();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash_info(
      std::string* hash_info);
  private:
  const std::string& _internal_hash_info() const;
  void _internal_set_hash_info(const std::string& value);
  std::string* _internal_mutable_hash_info();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.PrepareProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr proof_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// -------------------------------------------------------------------

class CalculateSha256Response PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:multichain.v1.CalculateSha256Response) */ {
 public:
  inline CalculateSha256Response() : CalculateSha256Response(nullptr) {};
  virtual ~CalculateSha256Response();

  CalculateSha256Response(const CalculateSha256Response& from);
  CalculateSha256Response(CalculateSha256Response&& from) noexcept
    : CalculateSha256Response() {
    *this = ::std::move(from);
  }

  inline CalculateSha256Response& operator=(const CalculateSha256Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CalculateSha256Response& operator=(CalculateSha256Response&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CalculateSha256Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CalculateSha256Response* internal_default_instance() {
    return reinterpret_cast<const CalculateSha256Response*>(
               &_CalculateSha256Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CalculateSha256Response& a, CalculateSha256Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CalculateSha256Response* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CalculateSha256Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CalculateSha256Response* New() const final {
    return CreateMaybeMessage<CalculateSha256Response>(nullptr);
  }

  CalculateSha256Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CalculateSha256Response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CalculateSha256Response& from);
  void MergeFrom(const CalculateSha256Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CalculateSha256Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "multichain.v1.CalculateSha256Response";
  }
  protected:
  explicit CalculateSha256Response(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_multichain_2eproto);
    return ::descriptor_table_multichain_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutHashFieldNumber = 1,
  };
  // string out_hash = 1;
  void clear_out_hash();
  const std::string& out_hash() const;
  void set_out_hash(const std::string& value);
  void set_out_hash(std::string&& value);
  void set_out_hash(const char* value);
  void set_out_hash(const char* value, size_t size);
  std::string* mutable_out_hash();
  std::string* release_out_hash();
  void set_allocated_out_hash(std::string* out_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_out_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_out_hash(
      std::string* out_hash);
  private:
  const std::string& _internal_out_hash() const;
  void _internal_set_out_hash(const std::string& value);
  std::string* _internal_mutable_out_hash();
  public:

  // @@protoc_insertion_point(class_scope:multichain.v1.CalculateSha256Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_multichain_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// string v0_0_1 = 1;
inline void Version::clear_v0_0_1() {
  v0_0_1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Version::v0_0_1() const {
  // @@protoc_insertion_point(field_get:multichain.v1.Version.v0_0_1)
  return _internal_v0_0_1();
}
inline void Version::set_v0_0_1(const std::string& value) {
  _internal_set_v0_0_1(value);
  // @@protoc_insertion_point(field_set:multichain.v1.Version.v0_0_1)
}
inline std::string* Version::mutable_v0_0_1() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.Version.v0_0_1)
  return _internal_mutable_v0_0_1();
}
inline const std::string& Version::_internal_v0_0_1() const {
  return v0_0_1_.Get();
}
inline void Version::_internal_set_v0_0_1(const std::string& value) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Version::set_v0_0_1(std::string&& value) {
  
  v0_0_1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.Version.v0_0_1)
}
inline void Version::set_v0_0_1(const char* value,
    size_t size) {
  
  v0_0_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.Version.v0_0_1)
}
inline std::string* Version::_internal_mutable_v0_0_1() {
  
  return v0_0_1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Version::release_v0_0_1() {
  // @@protoc_insertion_point(field_release:multichain.v1.Version.v0_0_1)
  return v0_0_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Version::set_allocated_v0_0_1(std::string* v0_0_1) {
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v0_0_1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.Version.v0_0_1)
}
inline std::string* Version::unsafe_arena_release_v0_0_1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.Version.v0_0_1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return v0_0_1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Version::unsafe_arena_set_allocated_v0_0_1(
    std::string* v0_0_1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (v0_0_1 != nullptr) {
    
  } else {
    
  }
  v0_0_1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      v0_0_1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.Version.v0_0_1)
}

// -------------------------------------------------------------------

// MultichainMessage

// string id = 1;
inline void MultichainMessage::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MultichainMessage::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.id)
  return _internal_id();
}
inline void MultichainMessage::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.MultichainMessage.id)
}
inline std::string* MultichainMessage::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.id)
  return _internal_mutable_id();
}
inline const std::string& MultichainMessage::_internal_id() const {
  return id_.Get();
}
inline void MultichainMessage::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MultichainMessage::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.MultichainMessage.id)
}
inline void MultichainMessage::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.MultichainMessage.id)
}
inline void MultichainMessage::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.MultichainMessage.id)
}
inline std::string* MultichainMessage::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MultichainMessage::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MultichainMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.MultichainMessage.id)
}
inline std::string* MultichainMessage::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MultichainMessage::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.id)
}

// .multichain.v1.GetStatusRequest get_status_request = 2;
inline bool MultichainMessage::_internal_has_get_status_request() const {
  return request_case() == kGetStatusRequest;
}
inline bool MultichainMessage::has_get_status_request() const {
  return _internal_has_get_status_request();
}
inline void MultichainMessage::set_has_get_status_request() {
  _oneof_case_[0] = kGetStatusRequest;
}
inline void MultichainMessage::clear_get_status_request() {
  if (_internal_has_get_status_request()) {
    if (GetArena() == nullptr) {
      delete request_.get_status_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::GetStatusRequest* MultichainMessage::release_get_status_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.get_status_request)
  if (_internal_has_get_status_request()) {
    clear_has_request();
      ::multichain::v1::GetStatusRequest* temp = request_.get_status_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GetStatusRequest& MultichainMessage::_internal_get_status_request() const {
  return _internal_has_get_status_request()
      ? *request_.get_status_request_
      : *reinterpret_cast< ::multichain::v1::GetStatusRequest*>(&::multichain::v1::_GetStatusRequest_default_instance_);
}
inline const ::multichain::v1::GetStatusRequest& MultichainMessage::get_status_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.get_status_request)
  return _internal_get_status_request();
}
inline ::multichain::v1::GetStatusRequest* MultichainMessage::unsafe_arena_release_get_status_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.get_status_request)
  if (_internal_has_get_status_request()) {
    clear_has_request();
    ::multichain::v1::GetStatusRequest* temp = request_.get_status_request_;
    request_.get_status_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_get_status_request(::multichain::v1::GetStatusRequest* get_status_request) {
  clear_request();
  if (get_status_request) {
    set_has_get_status_request();
    request_.get_status_request_ = get_status_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.get_status_request)
}
inline ::multichain::v1::GetStatusRequest* MultichainMessage::_internal_mutable_get_status_request() {
  if (!_internal_has_get_status_request()) {
    clear_request();
    set_has_get_status_request();
    request_.get_status_request_ = CreateMaybeMessage< ::multichain::v1::GetStatusRequest >(GetArena());
  }
  return request_.get_status_request_;
}
inline ::multichain::v1::GetStatusRequest* MultichainMessage::mutable_get_status_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.get_status_request)
  return _internal_mutable_get_status_request();
}

// .multichain.v1.GenPrepareMultichainProofRequest gen_prepare_multichain_proof_request = 3;
inline bool MultichainMessage::_internal_has_gen_prepare_multichain_proof_request() const {
  return request_case() == kGenPrepareMultichainProofRequest;
}
inline bool MultichainMessage::has_gen_prepare_multichain_proof_request() const {
  return _internal_has_gen_prepare_multichain_proof_request();
}
inline void MultichainMessage::set_has_gen_prepare_multichain_proof_request() {
  _oneof_case_[0] = kGenPrepareMultichainProofRequest;
}
inline void MultichainMessage::clear_gen_prepare_multichain_proof_request() {
  if (_internal_has_gen_prepare_multichain_proof_request()) {
    if (GetArena() == nullptr) {
      delete request_.gen_prepare_multichain_proof_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::GenPrepareMultichainProofRequest* MultichainMessage::release_gen_prepare_multichain_proof_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.gen_prepare_multichain_proof_request)
  if (_internal_has_gen_prepare_multichain_proof_request()) {
    clear_has_request();
      ::multichain::v1::GenPrepareMultichainProofRequest* temp = request_.gen_prepare_multichain_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.gen_prepare_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenPrepareMultichainProofRequest& MultichainMessage::_internal_gen_prepare_multichain_proof_request() const {
  return _internal_has_gen_prepare_multichain_proof_request()
      ? *request_.gen_prepare_multichain_proof_request_
      : *reinterpret_cast< ::multichain::v1::GenPrepareMultichainProofRequest*>(&::multichain::v1::_GenPrepareMultichainProofRequest_default_instance_);
}
inline const ::multichain::v1::GenPrepareMultichainProofRequest& MultichainMessage::gen_prepare_multichain_proof_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.gen_prepare_multichain_proof_request)
  return _internal_gen_prepare_multichain_proof_request();
}
inline ::multichain::v1::GenPrepareMultichainProofRequest* MultichainMessage::unsafe_arena_release_gen_prepare_multichain_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.gen_prepare_multichain_proof_request)
  if (_internal_has_gen_prepare_multichain_proof_request()) {
    clear_has_request();
    ::multichain::v1::GenPrepareMultichainProofRequest* temp = request_.gen_prepare_multichain_proof_request_;
    request_.gen_prepare_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_gen_prepare_multichain_proof_request(::multichain::v1::GenPrepareMultichainProofRequest* gen_prepare_multichain_proof_request) {
  clear_request();
  if (gen_prepare_multichain_proof_request) {
    set_has_gen_prepare_multichain_proof_request();
    request_.gen_prepare_multichain_proof_request_ = gen_prepare_multichain_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.gen_prepare_multichain_proof_request)
}
inline ::multichain::v1::GenPrepareMultichainProofRequest* MultichainMessage::_internal_mutable_gen_prepare_multichain_proof_request() {
  if (!_internal_has_gen_prepare_multichain_proof_request()) {
    clear_request();
    set_has_gen_prepare_multichain_proof_request();
    request_.gen_prepare_multichain_proof_request_ = CreateMaybeMessage< ::multichain::v1::GenPrepareMultichainProofRequest >(GetArena());
  }
  return request_.gen_prepare_multichain_proof_request_;
}
inline ::multichain::v1::GenPrepareMultichainProofRequest* MultichainMessage::mutable_gen_prepare_multichain_proof_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.gen_prepare_multichain_proof_request)
  return _internal_mutable_gen_prepare_multichain_proof_request();
}

// .multichain.v1.GenAggregatedMultichainProofRequest gen_aggregated_multichain_proof_request = 4;
inline bool MultichainMessage::_internal_has_gen_aggregated_multichain_proof_request() const {
  return request_case() == kGenAggregatedMultichainProofRequest;
}
inline bool MultichainMessage::has_gen_aggregated_multichain_proof_request() const {
  return _internal_has_gen_aggregated_multichain_proof_request();
}
inline void MultichainMessage::set_has_gen_aggregated_multichain_proof_request() {
  _oneof_case_[0] = kGenAggregatedMultichainProofRequest;
}
inline void MultichainMessage::clear_gen_aggregated_multichain_proof_request() {
  if (_internal_has_gen_aggregated_multichain_proof_request()) {
    if (GetArena() == nullptr) {
      delete request_.gen_aggregated_multichain_proof_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::GenAggregatedMultichainProofRequest* MultichainMessage::release_gen_aggregated_multichain_proof_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.gen_aggregated_multichain_proof_request)
  if (_internal_has_gen_aggregated_multichain_proof_request()) {
    clear_has_request();
      ::multichain::v1::GenAggregatedMultichainProofRequest* temp = request_.gen_aggregated_multichain_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.gen_aggregated_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenAggregatedMultichainProofRequest& MultichainMessage::_internal_gen_aggregated_multichain_proof_request() const {
  return _internal_has_gen_aggregated_multichain_proof_request()
      ? *request_.gen_aggregated_multichain_proof_request_
      : *reinterpret_cast< ::multichain::v1::GenAggregatedMultichainProofRequest*>(&::multichain::v1::_GenAggregatedMultichainProofRequest_default_instance_);
}
inline const ::multichain::v1::GenAggregatedMultichainProofRequest& MultichainMessage::gen_aggregated_multichain_proof_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.gen_aggregated_multichain_proof_request)
  return _internal_gen_aggregated_multichain_proof_request();
}
inline ::multichain::v1::GenAggregatedMultichainProofRequest* MultichainMessage::unsafe_arena_release_gen_aggregated_multichain_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.gen_aggregated_multichain_proof_request)
  if (_internal_has_gen_aggregated_multichain_proof_request()) {
    clear_has_request();
    ::multichain::v1::GenAggregatedMultichainProofRequest* temp = request_.gen_aggregated_multichain_proof_request_;
    request_.gen_aggregated_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_gen_aggregated_multichain_proof_request(::multichain::v1::GenAggregatedMultichainProofRequest* gen_aggregated_multichain_proof_request) {
  clear_request();
  if (gen_aggregated_multichain_proof_request) {
    set_has_gen_aggregated_multichain_proof_request();
    request_.gen_aggregated_multichain_proof_request_ = gen_aggregated_multichain_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.gen_aggregated_multichain_proof_request)
}
inline ::multichain::v1::GenAggregatedMultichainProofRequest* MultichainMessage::_internal_mutable_gen_aggregated_multichain_proof_request() {
  if (!_internal_has_gen_aggregated_multichain_proof_request()) {
    clear_request();
    set_has_gen_aggregated_multichain_proof_request();
    request_.gen_aggregated_multichain_proof_request_ = CreateMaybeMessage< ::multichain::v1::GenAggregatedMultichainProofRequest >(GetArena());
  }
  return request_.gen_aggregated_multichain_proof_request_;
}
inline ::multichain::v1::GenAggregatedMultichainProofRequest* MultichainMessage::mutable_gen_aggregated_multichain_proof_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.gen_aggregated_multichain_proof_request)
  return _internal_mutable_gen_aggregated_multichain_proof_request();
}

// .multichain.v1.GenFinalMultichainProofRequest gen_final_multichain_proof_request = 5;
inline bool MultichainMessage::_internal_has_gen_final_multichain_proof_request() const {
  return request_case() == kGenFinalMultichainProofRequest;
}
inline bool MultichainMessage::has_gen_final_multichain_proof_request() const {
  return _internal_has_gen_final_multichain_proof_request();
}
inline void MultichainMessage::set_has_gen_final_multichain_proof_request() {
  _oneof_case_[0] = kGenFinalMultichainProofRequest;
}
inline void MultichainMessage::clear_gen_final_multichain_proof_request() {
  if (_internal_has_gen_final_multichain_proof_request()) {
    if (GetArena() == nullptr) {
      delete request_.gen_final_multichain_proof_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::GenFinalMultichainProofRequest* MultichainMessage::release_gen_final_multichain_proof_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.gen_final_multichain_proof_request)
  if (_internal_has_gen_final_multichain_proof_request()) {
    clear_has_request();
      ::multichain::v1::GenFinalMultichainProofRequest* temp = request_.gen_final_multichain_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.gen_final_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenFinalMultichainProofRequest& MultichainMessage::_internal_gen_final_multichain_proof_request() const {
  return _internal_has_gen_final_multichain_proof_request()
      ? *request_.gen_final_multichain_proof_request_
      : *reinterpret_cast< ::multichain::v1::GenFinalMultichainProofRequest*>(&::multichain::v1::_GenFinalMultichainProofRequest_default_instance_);
}
inline const ::multichain::v1::GenFinalMultichainProofRequest& MultichainMessage::gen_final_multichain_proof_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.gen_final_multichain_proof_request)
  return _internal_gen_final_multichain_proof_request();
}
inline ::multichain::v1::GenFinalMultichainProofRequest* MultichainMessage::unsafe_arena_release_gen_final_multichain_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.gen_final_multichain_proof_request)
  if (_internal_has_gen_final_multichain_proof_request()) {
    clear_has_request();
    ::multichain::v1::GenFinalMultichainProofRequest* temp = request_.gen_final_multichain_proof_request_;
    request_.gen_final_multichain_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_gen_final_multichain_proof_request(::multichain::v1::GenFinalMultichainProofRequest* gen_final_multichain_proof_request) {
  clear_request();
  if (gen_final_multichain_proof_request) {
    set_has_gen_final_multichain_proof_request();
    request_.gen_final_multichain_proof_request_ = gen_final_multichain_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.gen_final_multichain_proof_request)
}
inline ::multichain::v1::GenFinalMultichainProofRequest* MultichainMessage::_internal_mutable_gen_final_multichain_proof_request() {
  if (!_internal_has_gen_final_multichain_proof_request()) {
    clear_request();
    set_has_gen_final_multichain_proof_request();
    request_.gen_final_multichain_proof_request_ = CreateMaybeMessage< ::multichain::v1::GenFinalMultichainProofRequest >(GetArena());
  }
  return request_.gen_final_multichain_proof_request_;
}
inline ::multichain::v1::GenFinalMultichainProofRequest* MultichainMessage::mutable_gen_final_multichain_proof_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.gen_final_multichain_proof_request)
  return _internal_mutable_gen_final_multichain_proof_request();
}

// .multichain.v1.CancelRequest cancel_request = 6;
inline bool MultichainMessage::_internal_has_cancel_request() const {
  return request_case() == kCancelRequest;
}
inline bool MultichainMessage::has_cancel_request() const {
  return _internal_has_cancel_request();
}
inline void MultichainMessage::set_has_cancel_request() {
  _oneof_case_[0] = kCancelRequest;
}
inline void MultichainMessage::clear_cancel_request() {
  if (_internal_has_cancel_request()) {
    if (GetArena() == nullptr) {
      delete request_.cancel_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::CancelRequest* MultichainMessage::release_cancel_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_request();
      ::multichain::v1::CancelRequest* temp = request_.cancel_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::CancelRequest& MultichainMessage::_internal_cancel_request() const {
  return _internal_has_cancel_request()
      ? *request_.cancel_request_
      : *reinterpret_cast< ::multichain::v1::CancelRequest*>(&::multichain::v1::_CancelRequest_default_instance_);
}
inline const ::multichain::v1::CancelRequest& MultichainMessage::cancel_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.cancel_request)
  return _internal_cancel_request();
}
inline ::multichain::v1::CancelRequest* MultichainMessage::unsafe_arena_release_cancel_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.cancel_request)
  if (_internal_has_cancel_request()) {
    clear_has_request();
    ::multichain::v1::CancelRequest* temp = request_.cancel_request_;
    request_.cancel_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_cancel_request(::multichain::v1::CancelRequest* cancel_request) {
  clear_request();
  if (cancel_request) {
    set_has_cancel_request();
    request_.cancel_request_ = cancel_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.cancel_request)
}
inline ::multichain::v1::CancelRequest* MultichainMessage::_internal_mutable_cancel_request() {
  if (!_internal_has_cancel_request()) {
    clear_request();
    set_has_cancel_request();
    request_.cancel_request_ = CreateMaybeMessage< ::multichain::v1::CancelRequest >(GetArena());
  }
  return request_.cancel_request_;
}
inline ::multichain::v1::CancelRequest* MultichainMessage::mutable_cancel_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.cancel_request)
  return _internal_mutable_cancel_request();
}

// .multichain.v1.GetProofRequest get_proof_request = 7;
inline bool MultichainMessage::_internal_has_get_proof_request() const {
  return request_case() == kGetProofRequest;
}
inline bool MultichainMessage::has_get_proof_request() const {
  return _internal_has_get_proof_request();
}
inline void MultichainMessage::set_has_get_proof_request() {
  _oneof_case_[0] = kGetProofRequest;
}
inline void MultichainMessage::clear_get_proof_request() {
  if (_internal_has_get_proof_request()) {
    if (GetArena() == nullptr) {
      delete request_.get_proof_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::GetProofRequest* MultichainMessage::release_get_proof_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.get_proof_request)
  if (_internal_has_get_proof_request()) {
    clear_has_request();
      ::multichain::v1::GetProofRequest* temp = request_.get_proof_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GetProofRequest& MultichainMessage::_internal_get_proof_request() const {
  return _internal_has_get_proof_request()
      ? *request_.get_proof_request_
      : *reinterpret_cast< ::multichain::v1::GetProofRequest*>(&::multichain::v1::_GetProofRequest_default_instance_);
}
inline const ::multichain::v1::GetProofRequest& MultichainMessage::get_proof_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.get_proof_request)
  return _internal_get_proof_request();
}
inline ::multichain::v1::GetProofRequest* MultichainMessage::unsafe_arena_release_get_proof_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.get_proof_request)
  if (_internal_has_get_proof_request()) {
    clear_has_request();
    ::multichain::v1::GetProofRequest* temp = request_.get_proof_request_;
    request_.get_proof_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_get_proof_request(::multichain::v1::GetProofRequest* get_proof_request) {
  clear_request();
  if (get_proof_request) {
    set_has_get_proof_request();
    request_.get_proof_request_ = get_proof_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.get_proof_request)
}
inline ::multichain::v1::GetProofRequest* MultichainMessage::_internal_mutable_get_proof_request() {
  if (!_internal_has_get_proof_request()) {
    clear_request();
    set_has_get_proof_request();
    request_.get_proof_request_ = CreateMaybeMessage< ::multichain::v1::GetProofRequest >(GetArena());
  }
  return request_.get_proof_request_;
}
inline ::multichain::v1::GetProofRequest* MultichainMessage::mutable_get_proof_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.get_proof_request)
  return _internal_mutable_get_proof_request();
}

// .multichain.v1.CalculateSha256Request calculate_sha256_request = 8;
inline bool MultichainMessage::_internal_has_calculate_sha256_request() const {
  return request_case() == kCalculateSha256Request;
}
inline bool MultichainMessage::has_calculate_sha256_request() const {
  return _internal_has_calculate_sha256_request();
}
inline void MultichainMessage::set_has_calculate_sha256_request() {
  _oneof_case_[0] = kCalculateSha256Request;
}
inline void MultichainMessage::clear_calculate_sha256_request() {
  if (_internal_has_calculate_sha256_request()) {
    if (GetArena() == nullptr) {
      delete request_.calculate_sha256_request_;
    }
    clear_has_request();
  }
}
inline ::multichain::v1::CalculateSha256Request* MultichainMessage::release_calculate_sha256_request() {
  // @@protoc_insertion_point(field_release:multichain.v1.MultichainMessage.calculate_sha256_request)
  if (_internal_has_calculate_sha256_request()) {
    clear_has_request();
      ::multichain::v1::CalculateSha256Request* temp = request_.calculate_sha256_request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.calculate_sha256_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::CalculateSha256Request& MultichainMessage::_internal_calculate_sha256_request() const {
  return _internal_has_calculate_sha256_request()
      ? *request_.calculate_sha256_request_
      : *reinterpret_cast< ::multichain::v1::CalculateSha256Request*>(&::multichain::v1::_CalculateSha256Request_default_instance_);
}
inline const ::multichain::v1::CalculateSha256Request& MultichainMessage::calculate_sha256_request() const {
  // @@protoc_insertion_point(field_get:multichain.v1.MultichainMessage.calculate_sha256_request)
  return _internal_calculate_sha256_request();
}
inline ::multichain::v1::CalculateSha256Request* MultichainMessage::unsafe_arena_release_calculate_sha256_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.MultichainMessage.calculate_sha256_request)
  if (_internal_has_calculate_sha256_request()) {
    clear_has_request();
    ::multichain::v1::CalculateSha256Request* temp = request_.calculate_sha256_request_;
    request_.calculate_sha256_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MultichainMessage::unsafe_arena_set_allocated_calculate_sha256_request(::multichain::v1::CalculateSha256Request* calculate_sha256_request) {
  clear_request();
  if (calculate_sha256_request) {
    set_has_calculate_sha256_request();
    request_.calculate_sha256_request_ = calculate_sha256_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.MultichainMessage.calculate_sha256_request)
}
inline ::multichain::v1::CalculateSha256Request* MultichainMessage::_internal_mutable_calculate_sha256_request() {
  if (!_internal_has_calculate_sha256_request()) {
    clear_request();
    set_has_calculate_sha256_request();
    request_.calculate_sha256_request_ = CreateMaybeMessage< ::multichain::v1::CalculateSha256Request >(GetArena());
  }
  return request_.calculate_sha256_request_;
}
inline ::multichain::v1::CalculateSha256Request* MultichainMessage::mutable_calculate_sha256_request() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.MultichainMessage.calculate_sha256_request)
  return _internal_mutable_calculate_sha256_request();
}

inline bool MultichainMessage::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void MultichainMessage::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline MultichainMessage::RequestCase MultichainMessage::request_case() const {
  return MultichainMessage::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProverMessage

// string id = 1;
inline void ProverMessage::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ProverMessage::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.id)
  return _internal_id();
}
inline void ProverMessage::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.ProverMessage.id)
}
inline std::string* ProverMessage::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.id)
  return _internal_mutable_id();
}
inline const std::string& ProverMessage::_internal_id() const {
  return id_.Get();
}
inline void ProverMessage::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProverMessage::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.ProverMessage.id)
}
inline void ProverMessage::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.ProverMessage.id)
}
inline void ProverMessage::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.ProverMessage.id)
}
inline std::string* ProverMessage::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProverMessage::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProverMessage::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.ProverMessage.id)
}
inline std::string* ProverMessage::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ProverMessage::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.id)
}

// .multichain.v1.GetStatusResponse get_status_response = 2;
inline bool ProverMessage::_internal_has_get_status_response() const {
  return response_case() == kGetStatusResponse;
}
inline bool ProverMessage::has_get_status_response() const {
  return _internal_has_get_status_response();
}
inline void ProverMessage::set_has_get_status_response() {
  _oneof_case_[0] = kGetStatusResponse;
}
inline void ProverMessage::clear_get_status_response() {
  if (_internal_has_get_status_response()) {
    if (GetArena() == nullptr) {
      delete response_.get_status_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::GetStatusResponse* ProverMessage::release_get_status_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.get_status_response)
  if (_internal_has_get_status_response()) {
    clear_has_response();
      ::multichain::v1::GetStatusResponse* temp = response_.get_status_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GetStatusResponse& ProverMessage::_internal_get_status_response() const {
  return _internal_has_get_status_response()
      ? *response_.get_status_response_
      : *reinterpret_cast< ::multichain::v1::GetStatusResponse*>(&::multichain::v1::_GetStatusResponse_default_instance_);
}
inline const ::multichain::v1::GetStatusResponse& ProverMessage::get_status_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.get_status_response)
  return _internal_get_status_response();
}
inline ::multichain::v1::GetStatusResponse* ProverMessage::unsafe_arena_release_get_status_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.get_status_response)
  if (_internal_has_get_status_response()) {
    clear_has_response();
    ::multichain::v1::GetStatusResponse* temp = response_.get_status_response_;
    response_.get_status_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_status_response(::multichain::v1::GetStatusResponse* get_status_response) {
  clear_response();
  if (get_status_response) {
    set_has_get_status_response();
    response_.get_status_response_ = get_status_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.get_status_response)
}
inline ::multichain::v1::GetStatusResponse* ProverMessage::_internal_mutable_get_status_response() {
  if (!_internal_has_get_status_response()) {
    clear_response();
    set_has_get_status_response();
    response_.get_status_response_ = CreateMaybeMessage< ::multichain::v1::GetStatusResponse >(GetArena());
  }
  return response_.get_status_response_;
}
inline ::multichain::v1::GetStatusResponse* ProverMessage::mutable_get_status_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.get_status_response)
  return _internal_mutable_get_status_response();
}

// .multichain.v1.GenPrepareMultichainProofResponse gen_prepare_multichain_proof_response = 3;
inline bool ProverMessage::_internal_has_gen_prepare_multichain_proof_response() const {
  return response_case() == kGenPrepareMultichainProofResponse;
}
inline bool ProverMessage::has_gen_prepare_multichain_proof_response() const {
  return _internal_has_gen_prepare_multichain_proof_response();
}
inline void ProverMessage::set_has_gen_prepare_multichain_proof_response() {
  _oneof_case_[0] = kGenPrepareMultichainProofResponse;
}
inline void ProverMessage::clear_gen_prepare_multichain_proof_response() {
  if (_internal_has_gen_prepare_multichain_proof_response()) {
    if (GetArena() == nullptr) {
      delete response_.gen_prepare_multichain_proof_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::GenPrepareMultichainProofResponse* ProverMessage::release_gen_prepare_multichain_proof_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.gen_prepare_multichain_proof_response)
  if (_internal_has_gen_prepare_multichain_proof_response()) {
    clear_has_response();
      ::multichain::v1::GenPrepareMultichainProofResponse* temp = response_.gen_prepare_multichain_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.gen_prepare_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenPrepareMultichainProofResponse& ProverMessage::_internal_gen_prepare_multichain_proof_response() const {
  return _internal_has_gen_prepare_multichain_proof_response()
      ? *response_.gen_prepare_multichain_proof_response_
      : *reinterpret_cast< ::multichain::v1::GenPrepareMultichainProofResponse*>(&::multichain::v1::_GenPrepareMultichainProofResponse_default_instance_);
}
inline const ::multichain::v1::GenPrepareMultichainProofResponse& ProverMessage::gen_prepare_multichain_proof_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.gen_prepare_multichain_proof_response)
  return _internal_gen_prepare_multichain_proof_response();
}
inline ::multichain::v1::GenPrepareMultichainProofResponse* ProverMessage::unsafe_arena_release_gen_prepare_multichain_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.gen_prepare_multichain_proof_response)
  if (_internal_has_gen_prepare_multichain_proof_response()) {
    clear_has_response();
    ::multichain::v1::GenPrepareMultichainProofResponse* temp = response_.gen_prepare_multichain_proof_response_;
    response_.gen_prepare_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_prepare_multichain_proof_response(::multichain::v1::GenPrepareMultichainProofResponse* gen_prepare_multichain_proof_response) {
  clear_response();
  if (gen_prepare_multichain_proof_response) {
    set_has_gen_prepare_multichain_proof_response();
    response_.gen_prepare_multichain_proof_response_ = gen_prepare_multichain_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.gen_prepare_multichain_proof_response)
}
inline ::multichain::v1::GenPrepareMultichainProofResponse* ProverMessage::_internal_mutable_gen_prepare_multichain_proof_response() {
  if (!_internal_has_gen_prepare_multichain_proof_response()) {
    clear_response();
    set_has_gen_prepare_multichain_proof_response();
    response_.gen_prepare_multichain_proof_response_ = CreateMaybeMessage< ::multichain::v1::GenPrepareMultichainProofResponse >(GetArena());
  }
  return response_.gen_prepare_multichain_proof_response_;
}
inline ::multichain::v1::GenPrepareMultichainProofResponse* ProverMessage::mutable_gen_prepare_multichain_proof_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.gen_prepare_multichain_proof_response)
  return _internal_mutable_gen_prepare_multichain_proof_response();
}

// .multichain.v1.GenAggregatedMultichainProofResponse gen_aggregated_multichain_proof_response = 4;
inline bool ProverMessage::_internal_has_gen_aggregated_multichain_proof_response() const {
  return response_case() == kGenAggregatedMultichainProofResponse;
}
inline bool ProverMessage::has_gen_aggregated_multichain_proof_response() const {
  return _internal_has_gen_aggregated_multichain_proof_response();
}
inline void ProverMessage::set_has_gen_aggregated_multichain_proof_response() {
  _oneof_case_[0] = kGenAggregatedMultichainProofResponse;
}
inline void ProverMessage::clear_gen_aggregated_multichain_proof_response() {
  if (_internal_has_gen_aggregated_multichain_proof_response()) {
    if (GetArena() == nullptr) {
      delete response_.gen_aggregated_multichain_proof_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::GenAggregatedMultichainProofResponse* ProverMessage::release_gen_aggregated_multichain_proof_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.gen_aggregated_multichain_proof_response)
  if (_internal_has_gen_aggregated_multichain_proof_response()) {
    clear_has_response();
      ::multichain::v1::GenAggregatedMultichainProofResponse* temp = response_.gen_aggregated_multichain_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.gen_aggregated_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenAggregatedMultichainProofResponse& ProverMessage::_internal_gen_aggregated_multichain_proof_response() const {
  return _internal_has_gen_aggregated_multichain_proof_response()
      ? *response_.gen_aggregated_multichain_proof_response_
      : *reinterpret_cast< ::multichain::v1::GenAggregatedMultichainProofResponse*>(&::multichain::v1::_GenAggregatedMultichainProofResponse_default_instance_);
}
inline const ::multichain::v1::GenAggregatedMultichainProofResponse& ProverMessage::gen_aggregated_multichain_proof_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.gen_aggregated_multichain_proof_response)
  return _internal_gen_aggregated_multichain_proof_response();
}
inline ::multichain::v1::GenAggregatedMultichainProofResponse* ProverMessage::unsafe_arena_release_gen_aggregated_multichain_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.gen_aggregated_multichain_proof_response)
  if (_internal_has_gen_aggregated_multichain_proof_response()) {
    clear_has_response();
    ::multichain::v1::GenAggregatedMultichainProofResponse* temp = response_.gen_aggregated_multichain_proof_response_;
    response_.gen_aggregated_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_aggregated_multichain_proof_response(::multichain::v1::GenAggregatedMultichainProofResponse* gen_aggregated_multichain_proof_response) {
  clear_response();
  if (gen_aggregated_multichain_proof_response) {
    set_has_gen_aggregated_multichain_proof_response();
    response_.gen_aggregated_multichain_proof_response_ = gen_aggregated_multichain_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.gen_aggregated_multichain_proof_response)
}
inline ::multichain::v1::GenAggregatedMultichainProofResponse* ProverMessage::_internal_mutable_gen_aggregated_multichain_proof_response() {
  if (!_internal_has_gen_aggregated_multichain_proof_response()) {
    clear_response();
    set_has_gen_aggregated_multichain_proof_response();
    response_.gen_aggregated_multichain_proof_response_ = CreateMaybeMessage< ::multichain::v1::GenAggregatedMultichainProofResponse >(GetArena());
  }
  return response_.gen_aggregated_multichain_proof_response_;
}
inline ::multichain::v1::GenAggregatedMultichainProofResponse* ProverMessage::mutable_gen_aggregated_multichain_proof_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.gen_aggregated_multichain_proof_response)
  return _internal_mutable_gen_aggregated_multichain_proof_response();
}

// .multichain.v1.GenFinalMultichainProofResponse gen_final_multichain_proof_response = 5;
inline bool ProverMessage::_internal_has_gen_final_multichain_proof_response() const {
  return response_case() == kGenFinalMultichainProofResponse;
}
inline bool ProverMessage::has_gen_final_multichain_proof_response() const {
  return _internal_has_gen_final_multichain_proof_response();
}
inline void ProverMessage::set_has_gen_final_multichain_proof_response() {
  _oneof_case_[0] = kGenFinalMultichainProofResponse;
}
inline void ProverMessage::clear_gen_final_multichain_proof_response() {
  if (_internal_has_gen_final_multichain_proof_response()) {
    if (GetArena() == nullptr) {
      delete response_.gen_final_multichain_proof_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::GenFinalMultichainProofResponse* ProverMessage::release_gen_final_multichain_proof_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.gen_final_multichain_proof_response)
  if (_internal_has_gen_final_multichain_proof_response()) {
    clear_has_response();
      ::multichain::v1::GenFinalMultichainProofResponse* temp = response_.gen_final_multichain_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.gen_final_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GenFinalMultichainProofResponse& ProverMessage::_internal_gen_final_multichain_proof_response() const {
  return _internal_has_gen_final_multichain_proof_response()
      ? *response_.gen_final_multichain_proof_response_
      : *reinterpret_cast< ::multichain::v1::GenFinalMultichainProofResponse*>(&::multichain::v1::_GenFinalMultichainProofResponse_default_instance_);
}
inline const ::multichain::v1::GenFinalMultichainProofResponse& ProverMessage::gen_final_multichain_proof_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.gen_final_multichain_proof_response)
  return _internal_gen_final_multichain_proof_response();
}
inline ::multichain::v1::GenFinalMultichainProofResponse* ProverMessage::unsafe_arena_release_gen_final_multichain_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.gen_final_multichain_proof_response)
  if (_internal_has_gen_final_multichain_proof_response()) {
    clear_has_response();
    ::multichain::v1::GenFinalMultichainProofResponse* temp = response_.gen_final_multichain_proof_response_;
    response_.gen_final_multichain_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_gen_final_multichain_proof_response(::multichain::v1::GenFinalMultichainProofResponse* gen_final_multichain_proof_response) {
  clear_response();
  if (gen_final_multichain_proof_response) {
    set_has_gen_final_multichain_proof_response();
    response_.gen_final_multichain_proof_response_ = gen_final_multichain_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.gen_final_multichain_proof_response)
}
inline ::multichain::v1::GenFinalMultichainProofResponse* ProverMessage::_internal_mutable_gen_final_multichain_proof_response() {
  if (!_internal_has_gen_final_multichain_proof_response()) {
    clear_response();
    set_has_gen_final_multichain_proof_response();
    response_.gen_final_multichain_proof_response_ = CreateMaybeMessage< ::multichain::v1::GenFinalMultichainProofResponse >(GetArena());
  }
  return response_.gen_final_multichain_proof_response_;
}
inline ::multichain::v1::GenFinalMultichainProofResponse* ProverMessage::mutable_gen_final_multichain_proof_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.gen_final_multichain_proof_response)
  return _internal_mutable_gen_final_multichain_proof_response();
}

// .multichain.v1.CancelResponse cancel_response = 6;
inline bool ProverMessage::_internal_has_cancel_response() const {
  return response_case() == kCancelResponse;
}
inline bool ProverMessage::has_cancel_response() const {
  return _internal_has_cancel_response();
}
inline void ProverMessage::set_has_cancel_response() {
  _oneof_case_[0] = kCancelResponse;
}
inline void ProverMessage::clear_cancel_response() {
  if (_internal_has_cancel_response()) {
    if (GetArena() == nullptr) {
      delete response_.cancel_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::CancelResponse* ProverMessage::release_cancel_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.cancel_response)
  if (_internal_has_cancel_response()) {
    clear_has_response();
      ::multichain::v1::CancelResponse* temp = response_.cancel_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::CancelResponse& ProverMessage::_internal_cancel_response() const {
  return _internal_has_cancel_response()
      ? *response_.cancel_response_
      : *reinterpret_cast< ::multichain::v1::CancelResponse*>(&::multichain::v1::_CancelResponse_default_instance_);
}
inline const ::multichain::v1::CancelResponse& ProverMessage::cancel_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.cancel_response)
  return _internal_cancel_response();
}
inline ::multichain::v1::CancelResponse* ProverMessage::unsafe_arena_release_cancel_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.cancel_response)
  if (_internal_has_cancel_response()) {
    clear_has_response();
    ::multichain::v1::CancelResponse* temp = response_.cancel_response_;
    response_.cancel_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_cancel_response(::multichain::v1::CancelResponse* cancel_response) {
  clear_response();
  if (cancel_response) {
    set_has_cancel_response();
    response_.cancel_response_ = cancel_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.cancel_response)
}
inline ::multichain::v1::CancelResponse* ProverMessage::_internal_mutable_cancel_response() {
  if (!_internal_has_cancel_response()) {
    clear_response();
    set_has_cancel_response();
    response_.cancel_response_ = CreateMaybeMessage< ::multichain::v1::CancelResponse >(GetArena());
  }
  return response_.cancel_response_;
}
inline ::multichain::v1::CancelResponse* ProverMessage::mutable_cancel_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.cancel_response)
  return _internal_mutable_cancel_response();
}

// .multichain.v1.GetProofResponse get_proof_response = 7;
inline bool ProverMessage::_internal_has_get_proof_response() const {
  return response_case() == kGetProofResponse;
}
inline bool ProverMessage::has_get_proof_response() const {
  return _internal_has_get_proof_response();
}
inline void ProverMessage::set_has_get_proof_response() {
  _oneof_case_[0] = kGetProofResponse;
}
inline void ProverMessage::clear_get_proof_response() {
  if (_internal_has_get_proof_response()) {
    if (GetArena() == nullptr) {
      delete response_.get_proof_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::GetProofResponse* ProverMessage::release_get_proof_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.get_proof_response)
  if (_internal_has_get_proof_response()) {
    clear_has_response();
      ::multichain::v1::GetProofResponse* temp = response_.get_proof_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::GetProofResponse& ProverMessage::_internal_get_proof_response() const {
  return _internal_has_get_proof_response()
      ? *response_.get_proof_response_
      : *reinterpret_cast< ::multichain::v1::GetProofResponse*>(&::multichain::v1::_GetProofResponse_default_instance_);
}
inline const ::multichain::v1::GetProofResponse& ProverMessage::get_proof_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.get_proof_response)
  return _internal_get_proof_response();
}
inline ::multichain::v1::GetProofResponse* ProverMessage::unsafe_arena_release_get_proof_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.get_proof_response)
  if (_internal_has_get_proof_response()) {
    clear_has_response();
    ::multichain::v1::GetProofResponse* temp = response_.get_proof_response_;
    response_.get_proof_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_get_proof_response(::multichain::v1::GetProofResponse* get_proof_response) {
  clear_response();
  if (get_proof_response) {
    set_has_get_proof_response();
    response_.get_proof_response_ = get_proof_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.get_proof_response)
}
inline ::multichain::v1::GetProofResponse* ProverMessage::_internal_mutable_get_proof_response() {
  if (!_internal_has_get_proof_response()) {
    clear_response();
    set_has_get_proof_response();
    response_.get_proof_response_ = CreateMaybeMessage< ::multichain::v1::GetProofResponse >(GetArena());
  }
  return response_.get_proof_response_;
}
inline ::multichain::v1::GetProofResponse* ProverMessage::mutable_get_proof_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.get_proof_response)
  return _internal_mutable_get_proof_response();
}

// .multichain.v1.CalculateSha256Response calculate_sha256_response = 8;
inline bool ProverMessage::_internal_has_calculate_sha256_response() const {
  return response_case() == kCalculateSha256Response;
}
inline bool ProverMessage::has_calculate_sha256_response() const {
  return _internal_has_calculate_sha256_response();
}
inline void ProverMessage::set_has_calculate_sha256_response() {
  _oneof_case_[0] = kCalculateSha256Response;
}
inline void ProverMessage::clear_calculate_sha256_response() {
  if (_internal_has_calculate_sha256_response()) {
    if (GetArena() == nullptr) {
      delete response_.calculate_sha256_response_;
    }
    clear_has_response();
  }
}
inline ::multichain::v1::CalculateSha256Response* ProverMessage::release_calculate_sha256_response() {
  // @@protoc_insertion_point(field_release:multichain.v1.ProverMessage.calculate_sha256_response)
  if (_internal_has_calculate_sha256_response()) {
    clear_has_response();
      ::multichain::v1::CalculateSha256Response* temp = response_.calculate_sha256_response_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.calculate_sha256_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::CalculateSha256Response& ProverMessage::_internal_calculate_sha256_response() const {
  return _internal_has_calculate_sha256_response()
      ? *response_.calculate_sha256_response_
      : *reinterpret_cast< ::multichain::v1::CalculateSha256Response*>(&::multichain::v1::_CalculateSha256Response_default_instance_);
}
inline const ::multichain::v1::CalculateSha256Response& ProverMessage::calculate_sha256_response() const {
  // @@protoc_insertion_point(field_get:multichain.v1.ProverMessage.calculate_sha256_response)
  return _internal_calculate_sha256_response();
}
inline ::multichain::v1::CalculateSha256Response* ProverMessage::unsafe_arena_release_calculate_sha256_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.ProverMessage.calculate_sha256_response)
  if (_internal_has_calculate_sha256_response()) {
    clear_has_response();
    ::multichain::v1::CalculateSha256Response* temp = response_.calculate_sha256_response_;
    response_.calculate_sha256_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ProverMessage::unsafe_arena_set_allocated_calculate_sha256_response(::multichain::v1::CalculateSha256Response* calculate_sha256_response) {
  clear_response();
  if (calculate_sha256_response) {
    set_has_calculate_sha256_response();
    response_.calculate_sha256_response_ = calculate_sha256_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.ProverMessage.calculate_sha256_response)
}
inline ::multichain::v1::CalculateSha256Response* ProverMessage::_internal_mutable_calculate_sha256_response() {
  if (!_internal_has_calculate_sha256_response()) {
    clear_response();
    set_has_calculate_sha256_response();
    response_.calculate_sha256_response_ = CreateMaybeMessage< ::multichain::v1::CalculateSha256Response >(GetArena());
  }
  return response_.calculate_sha256_response_;
}
inline ::multichain::v1::CalculateSha256Response* ProverMessage::mutable_calculate_sha256_response() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.ProverMessage.calculate_sha256_response)
  return _internal_mutable_calculate_sha256_response();
}

inline bool ProverMessage::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ProverMessage::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ProverMessage::ResponseCase ProverMessage::response_case() const {
  return ProverMessage::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetStatusRequest

// -------------------------------------------------------------------

// GenPrepareMultichainProofRequest

// string recursive_proof = 1;
inline void GenPrepareMultichainProofRequest::clear_recursive_proof() {
  recursive_proof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenPrepareMultichainProofRequest::recursive_proof() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
  return _internal_recursive_proof();
}
inline void GenPrepareMultichainProofRequest::set_recursive_proof(const std::string& value) {
  _internal_set_recursive_proof(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}
inline std::string* GenPrepareMultichainProofRequest::mutable_recursive_proof() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
  return _internal_mutable_recursive_proof();
}
inline const std::string& GenPrepareMultichainProofRequest::_internal_recursive_proof() const {
  return recursive_proof_.Get();
}
inline void GenPrepareMultichainProofRequest::_internal_set_recursive_proof(const std::string& value) {
  
  recursive_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenPrepareMultichainProofRequest::set_recursive_proof(std::string&& value) {
  
  recursive_proof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}
inline void GenPrepareMultichainProofRequest::set_recursive_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  recursive_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}
inline void GenPrepareMultichainProofRequest::set_recursive_proof(const char* value,
    size_t size) {
  
  recursive_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}
inline std::string* GenPrepareMultichainProofRequest::_internal_mutable_recursive_proof() {
  
  return recursive_proof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenPrepareMultichainProofRequest::release_recursive_proof() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
  return recursive_proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenPrepareMultichainProofRequest::set_allocated_recursive_proof(std::string* recursive_proof) {
  if (recursive_proof != nullptr) {
    
  } else {
    
  }
  recursive_proof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recursive_proof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}
inline std::string* GenPrepareMultichainProofRequest::unsafe_arena_release_recursive_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return recursive_proof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenPrepareMultichainProofRequest::unsafe_arena_set_allocated_recursive_proof(
    std::string* recursive_proof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (recursive_proof != nullptr) {
    
  } else {
    
  }
  recursive_proof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      recursive_proof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenPrepareMultichainProofRequest.recursive_proof)
}

// string previous_hash = 2;
inline void GenPrepareMultichainProofRequest::clear_previous_hash() {
  previous_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenPrepareMultichainProofRequest::previous_hash() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
  return _internal_previous_hash();
}
inline void GenPrepareMultichainProofRequest::set_previous_hash(const std::string& value) {
  _internal_set_previous_hash(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}
inline std::string* GenPrepareMultichainProofRequest::mutable_previous_hash() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
  return _internal_mutable_previous_hash();
}
inline const std::string& GenPrepareMultichainProofRequest::_internal_previous_hash() const {
  return previous_hash_.Get();
}
inline void GenPrepareMultichainProofRequest::_internal_set_previous_hash(const std::string& value) {
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenPrepareMultichainProofRequest::set_previous_hash(std::string&& value) {
  
  previous_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}
inline void GenPrepareMultichainProofRequest::set_previous_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}
inline void GenPrepareMultichainProofRequest::set_previous_hash(const char* value,
    size_t size) {
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}
inline std::string* GenPrepareMultichainProofRequest::_internal_mutable_previous_hash() {
  
  return previous_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenPrepareMultichainProofRequest::release_previous_hash() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
  return previous_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenPrepareMultichainProofRequest::set_allocated_previous_hash(std::string* previous_hash) {
  if (previous_hash != nullptr) {
    
  } else {
    
  }
  previous_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}
inline std::string* GenPrepareMultichainProofRequest::unsafe_arena_release_previous_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return previous_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenPrepareMultichainProofRequest::unsafe_arena_set_allocated_previous_hash(
    std::string* previous_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (previous_hash != nullptr) {
    
  } else {
    
  }
  previous_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      previous_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenPrepareMultichainProofRequest.previous_hash)
}

// -------------------------------------------------------------------

// GenAggregatedMultichainProofRequest

// string multichain_proof_1 = 1;
inline void GenAggregatedMultichainProofRequest::clear_multichain_proof_1() {
  multichain_proof_1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenAggregatedMultichainProofRequest::multichain_proof_1() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
  return _internal_multichain_proof_1();
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_1(const std::string& value) {
  _internal_set_multichain_proof_1(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}
inline std::string* GenAggregatedMultichainProofRequest::mutable_multichain_proof_1() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
  return _internal_mutable_multichain_proof_1();
}
inline const std::string& GenAggregatedMultichainProofRequest::_internal_multichain_proof_1() const {
  return multichain_proof_1_.Get();
}
inline void GenAggregatedMultichainProofRequest::_internal_set_multichain_proof_1(const std::string& value) {
  
  multichain_proof_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_1(std::string&& value) {
  
  multichain_proof_1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  multichain_proof_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_1(const char* value,
    size_t size) {
  
  multichain_proof_1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}
inline std::string* GenAggregatedMultichainProofRequest::_internal_mutable_multichain_proof_1() {
  
  return multichain_proof_1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenAggregatedMultichainProofRequest::release_multichain_proof_1() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
  return multichain_proof_1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenAggregatedMultichainProofRequest::set_allocated_multichain_proof_1(std::string* multichain_proof_1) {
  if (multichain_proof_1 != nullptr) {
    
  } else {
    
  }
  multichain_proof_1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multichain_proof_1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}
inline std::string* GenAggregatedMultichainProofRequest::unsafe_arena_release_multichain_proof_1() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return multichain_proof_1_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenAggregatedMultichainProofRequest::unsafe_arena_set_allocated_multichain_proof_1(
    std::string* multichain_proof_1) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (multichain_proof_1 != nullptr) {
    
  } else {
    
  }
  multichain_proof_1_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      multichain_proof_1, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_1)
}

// string multichain_proof_2 = 2;
inline void GenAggregatedMultichainProofRequest::clear_multichain_proof_2() {
  multichain_proof_2_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenAggregatedMultichainProofRequest::multichain_proof_2() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
  return _internal_multichain_proof_2();
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_2(const std::string& value) {
  _internal_set_multichain_proof_2(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}
inline std::string* GenAggregatedMultichainProofRequest::mutable_multichain_proof_2() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
  return _internal_mutable_multichain_proof_2();
}
inline const std::string& GenAggregatedMultichainProofRequest::_internal_multichain_proof_2() const {
  return multichain_proof_2_.Get();
}
inline void GenAggregatedMultichainProofRequest::_internal_set_multichain_proof_2(const std::string& value) {
  
  multichain_proof_2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_2(std::string&& value) {
  
  multichain_proof_2_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  multichain_proof_2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}
inline void GenAggregatedMultichainProofRequest::set_multichain_proof_2(const char* value,
    size_t size) {
  
  multichain_proof_2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}
inline std::string* GenAggregatedMultichainProofRequest::_internal_mutable_multichain_proof_2() {
  
  return multichain_proof_2_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenAggregatedMultichainProofRequest::release_multichain_proof_2() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
  return multichain_proof_2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenAggregatedMultichainProofRequest::set_allocated_multichain_proof_2(std::string* multichain_proof_2) {
  if (multichain_proof_2 != nullptr) {
    
  } else {
    
  }
  multichain_proof_2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multichain_proof_2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}
inline std::string* GenAggregatedMultichainProofRequest::unsafe_arena_release_multichain_proof_2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return multichain_proof_2_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenAggregatedMultichainProofRequest::unsafe_arena_set_allocated_multichain_proof_2(
    std::string* multichain_proof_2) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (multichain_proof_2 != nullptr) {
    
  } else {
    
  }
  multichain_proof_2_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      multichain_proof_2, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenAggregatedMultichainProofRequest.multichain_proof_2)
}

// -------------------------------------------------------------------

// GenFinalMultichainProofRequest

// string multichain_proof = 1;
inline void GenFinalMultichainProofRequest::clear_multichain_proof() {
  multichain_proof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenFinalMultichainProofRequest::multichain_proof() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
  return _internal_multichain_proof();
}
inline void GenFinalMultichainProofRequest::set_multichain_proof(const std::string& value) {
  _internal_set_multichain_proof(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}
inline std::string* GenFinalMultichainProofRequest::mutable_multichain_proof() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
  return _internal_mutable_multichain_proof();
}
inline const std::string& GenFinalMultichainProofRequest::_internal_multichain_proof() const {
  return multichain_proof_.Get();
}
inline void GenFinalMultichainProofRequest::_internal_set_multichain_proof(const std::string& value) {
  
  multichain_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenFinalMultichainProofRequest::set_multichain_proof(std::string&& value) {
  
  multichain_proof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}
inline void GenFinalMultichainProofRequest::set_multichain_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  multichain_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}
inline void GenFinalMultichainProofRequest::set_multichain_proof(const char* value,
    size_t size) {
  
  multichain_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}
inline std::string* GenFinalMultichainProofRequest::_internal_mutable_multichain_proof() {
  
  return multichain_proof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenFinalMultichainProofRequest::release_multichain_proof() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
  return multichain_proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenFinalMultichainProofRequest::set_allocated_multichain_proof(std::string* multichain_proof) {
  if (multichain_proof != nullptr) {
    
  } else {
    
  }
  multichain_proof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multichain_proof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}
inline std::string* GenFinalMultichainProofRequest::unsafe_arena_release_multichain_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return multichain_proof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenFinalMultichainProofRequest::unsafe_arena_set_allocated_multichain_proof(
    std::string* multichain_proof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (multichain_proof != nullptr) {
    
  } else {
    
  }
  multichain_proof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      multichain_proof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenFinalMultichainProofRequest.multichain_proof)
}

// string aggregator_addr = 2;
inline void GenFinalMultichainProofRequest::clear_aggregator_addr() {
  aggregator_addr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenFinalMultichainProofRequest::aggregator_addr() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
  return _internal_aggregator_addr();
}
inline void GenFinalMultichainProofRequest::set_aggregator_addr(const std::string& value) {
  _internal_set_aggregator_addr(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}
inline std::string* GenFinalMultichainProofRequest::mutable_aggregator_addr() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
  return _internal_mutable_aggregator_addr();
}
inline const std::string& GenFinalMultichainProofRequest::_internal_aggregator_addr() const {
  return aggregator_addr_.Get();
}
inline void GenFinalMultichainProofRequest::_internal_set_aggregator_addr(const std::string& value) {
  
  aggregator_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenFinalMultichainProofRequest::set_aggregator_addr(std::string&& value) {
  
  aggregator_addr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}
inline void GenFinalMultichainProofRequest::set_aggregator_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  aggregator_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}
inline void GenFinalMultichainProofRequest::set_aggregator_addr(const char* value,
    size_t size) {
  
  aggregator_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}
inline std::string* GenFinalMultichainProofRequest::_internal_mutable_aggregator_addr() {
  
  return aggregator_addr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenFinalMultichainProofRequest::release_aggregator_addr() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
  return aggregator_addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenFinalMultichainProofRequest::set_allocated_aggregator_addr(std::string* aggregator_addr) {
  if (aggregator_addr != nullptr) {
    
  } else {
    
  }
  aggregator_addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), aggregator_addr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}
inline std::string* GenFinalMultichainProofRequest::unsafe_arena_release_aggregator_addr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return aggregator_addr_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenFinalMultichainProofRequest::unsafe_arena_set_allocated_aggregator_addr(
    std::string* aggregator_addr) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (aggregator_addr != nullptr) {
    
  } else {
    
  }
  aggregator_addr_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      aggregator_addr, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenFinalMultichainProofRequest.aggregator_addr)
}

// -------------------------------------------------------------------

// CancelRequest

// string id = 1;
inline void CancelRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CancelRequest::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.CancelRequest.id)
  return _internal_id();
}
inline void CancelRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.CancelRequest.id)
}
inline std::string* CancelRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.CancelRequest.id)
  return _internal_mutable_id();
}
inline const std::string& CancelRequest::_internal_id() const {
  return id_.Get();
}
inline void CancelRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CancelRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.CancelRequest.id)
}
inline void CancelRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.CancelRequest.id)
}
inline void CancelRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.CancelRequest.id)
}
inline std::string* CancelRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CancelRequest::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.CancelRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CancelRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.CancelRequest.id)
}
inline std::string* CancelRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.CancelRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CancelRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.CancelRequest.id)
}

// -------------------------------------------------------------------

// GetProofRequest

// string id = 1;
inline void GetProofRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetProofRequest::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofRequest.id)
  return _internal_id();
}
inline void GetProofRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofRequest.id)
}
inline std::string* GetProofRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetProofRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GetProofRequest::_internal_id() const {
  return id_.Get();
}
inline void GetProofRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProofRequest::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetProofRequest.id)
}
inline void GetProofRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetProofRequest.id)
}
inline void GetProofRequest::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetProofRequest.id)
}
inline std::string* GetProofRequest::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProofRequest::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetProofRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetProofRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetProofRequest.id)
}
inline std::string* GetProofRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetProofRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetProofRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetProofRequest.id)
}

// uint64 timeout = 2;
inline void GetProofRequest::clear_timeout() {
  timeout_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetProofRequest::_internal_timeout() const {
  return timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetProofRequest::timeout() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofRequest.timeout)
  return _internal_timeout();
}
inline void GetProofRequest::_internal_set_timeout(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timeout_ = value;
}
inline void GetProofRequest::set_timeout(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofRequest.timeout)
}

// -------------------------------------------------------------------

// CalculateSha256Request

// string publics = 1;
inline void CalculateSha256Request::clear_publics() {
  publics_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CalculateSha256Request::publics() const {
  // @@protoc_insertion_point(field_get:multichain.v1.CalculateSha256Request.publics)
  return _internal_publics();
}
inline void CalculateSha256Request::set_publics(const std::string& value) {
  _internal_set_publics(value);
  // @@protoc_insertion_point(field_set:multichain.v1.CalculateSha256Request.publics)
}
inline std::string* CalculateSha256Request::mutable_publics() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.CalculateSha256Request.publics)
  return _internal_mutable_publics();
}
inline const std::string& CalculateSha256Request::_internal_publics() const {
  return publics_.Get();
}
inline void CalculateSha256Request::_internal_set_publics(const std::string& value) {
  
  publics_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CalculateSha256Request::set_publics(std::string&& value) {
  
  publics_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.CalculateSha256Request.publics)
}
inline void CalculateSha256Request::set_publics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  publics_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.CalculateSha256Request.publics)
}
inline void CalculateSha256Request::set_publics(const char* value,
    size_t size) {
  
  publics_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.CalculateSha256Request.publics)
}
inline std::string* CalculateSha256Request::_internal_mutable_publics() {
  
  return publics_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CalculateSha256Request::release_publics() {
  // @@protoc_insertion_point(field_release:multichain.v1.CalculateSha256Request.publics)
  return publics_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CalculateSha256Request::set_allocated_publics(std::string* publics) {
  if (publics != nullptr) {
    
  } else {
    
  }
  publics_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publics,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.CalculateSha256Request.publics)
}
inline std::string* CalculateSha256Request::unsafe_arena_release_publics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.CalculateSha256Request.publics)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return publics_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CalculateSha256Request::unsafe_arena_set_allocated_publics(
    std::string* publics) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (publics != nullptr) {
    
  } else {
    
  }
  publics_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      publics, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.CalculateSha256Request.publics)
}

// string previous_hash = 2;
inline void CalculateSha256Request::clear_previous_hash() {
  previous_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CalculateSha256Request::previous_hash() const {
  // @@protoc_insertion_point(field_get:multichain.v1.CalculateSha256Request.previous_hash)
  return _internal_previous_hash();
}
inline void CalculateSha256Request::set_previous_hash(const std::string& value) {
  _internal_set_previous_hash(value);
  // @@protoc_insertion_point(field_set:multichain.v1.CalculateSha256Request.previous_hash)
}
inline std::string* CalculateSha256Request::mutable_previous_hash() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.CalculateSha256Request.previous_hash)
  return _internal_mutable_previous_hash();
}
inline const std::string& CalculateSha256Request::_internal_previous_hash() const {
  return previous_hash_.Get();
}
inline void CalculateSha256Request::_internal_set_previous_hash(const std::string& value) {
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CalculateSha256Request::set_previous_hash(std::string&& value) {
  
  previous_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.CalculateSha256Request.previous_hash)
}
inline void CalculateSha256Request::set_previous_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.CalculateSha256Request.previous_hash)
}
inline void CalculateSha256Request::set_previous_hash(const char* value,
    size_t size) {
  
  previous_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.CalculateSha256Request.previous_hash)
}
inline std::string* CalculateSha256Request::_internal_mutable_previous_hash() {
  
  return previous_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CalculateSha256Request::release_previous_hash() {
  // @@protoc_insertion_point(field_release:multichain.v1.CalculateSha256Request.previous_hash)
  return previous_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CalculateSha256Request::set_allocated_previous_hash(std::string* previous_hash) {
  if (previous_hash != nullptr) {
    
  } else {
    
  }
  previous_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.CalculateSha256Request.previous_hash)
}
inline std::string* CalculateSha256Request::unsafe_arena_release_previous_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.CalculateSha256Request.previous_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return previous_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CalculateSha256Request::unsafe_arena_set_allocated_previous_hash(
    std::string* previous_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (previous_hash != nullptr) {
    
  } else {
    
  }
  previous_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      previous_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.CalculateSha256Request.previous_hash)
}

// -------------------------------------------------------------------

// GetStatusResponse

// .multichain.v1.GetStatusResponse.Status status = 1;
inline void GetStatusResponse::clear_status() {
  status_ = 0;
}
inline ::multichain::v1::GetStatusResponse_Status GetStatusResponse::_internal_status() const {
  return static_cast< ::multichain::v1::GetStatusResponse_Status >(status_);
}
inline ::multichain::v1::GetStatusResponse_Status GetStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.status)
  return _internal_status();
}
inline void GetStatusResponse::_internal_set_status(::multichain::v1::GetStatusResponse_Status value) {
  
  status_ = value;
}
inline void GetStatusResponse::set_status(::multichain::v1::GetStatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.status)
}

// string last_computed_request_id = 2;
inline void GetStatusResponse::clear_last_computed_request_id() {
  last_computed_request_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::last_computed_request_id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.last_computed_request_id)
  return _internal_last_computed_request_id();
}
inline void GetStatusResponse::set_last_computed_request_id(const std::string& value) {
  _internal_set_last_computed_request_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.last_computed_request_id)
}
inline std::string* GetStatusResponse::mutable_last_computed_request_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.last_computed_request_id)
  return _internal_mutable_last_computed_request_id();
}
inline const std::string& GetStatusResponse::_internal_last_computed_request_id() const {
  return last_computed_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_last_computed_request_id(const std::string& value) {
  
  last_computed_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_last_computed_request_id(std::string&& value) {
  
  last_computed_request_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.last_computed_request_id)
}
inline void GetStatusResponse::set_last_computed_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  last_computed_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.last_computed_request_id)
}
inline void GetStatusResponse::set_last_computed_request_id(const char* value,
    size_t size) {
  
  last_computed_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.last_computed_request_id)
}
inline std::string* GetStatusResponse::_internal_mutable_last_computed_request_id() {
  
  return last_computed_request_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_last_computed_request_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.last_computed_request_id)
  return last_computed_request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_last_computed_request_id(std::string* last_computed_request_id) {
  if (last_computed_request_id != nullptr) {
    
  } else {
    
  }
  last_computed_request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_computed_request_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.last_computed_request_id)
}
inline std::string* GetStatusResponse::unsafe_arena_release_last_computed_request_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.last_computed_request_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return last_computed_request_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_last_computed_request_id(
    std::string* last_computed_request_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (last_computed_request_id != nullptr) {
    
  } else {
    
  }
  last_computed_request_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      last_computed_request_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.last_computed_request_id)
}

// uint64 last_computed_end_time = 3;
inline void GetStatusResponse::clear_last_computed_end_time() {
  last_computed_end_time_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_last_computed_end_time() const {
  return last_computed_end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::last_computed_end_time() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.last_computed_end_time)
  return _internal_last_computed_end_time();
}
inline void GetStatusResponse::_internal_set_last_computed_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  last_computed_end_time_ = value;
}
inline void GetStatusResponse::set_last_computed_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_last_computed_end_time(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.last_computed_end_time)
}

// string current_computing_request_id = 4;
inline void GetStatusResponse::clear_current_computing_request_id() {
  current_computing_request_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::current_computing_request_id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.current_computing_request_id)
  return _internal_current_computing_request_id();
}
inline void GetStatusResponse::set_current_computing_request_id(const std::string& value) {
  _internal_set_current_computing_request_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.current_computing_request_id)
}
inline std::string* GetStatusResponse::mutable_current_computing_request_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.current_computing_request_id)
  return _internal_mutable_current_computing_request_id();
}
inline const std::string& GetStatusResponse::_internal_current_computing_request_id() const {
  return current_computing_request_id_.Get();
}
inline void GetStatusResponse::_internal_set_current_computing_request_id(const std::string& value) {
  
  current_computing_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_current_computing_request_id(std::string&& value) {
  
  current_computing_request_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.current_computing_request_id)
}
inline void GetStatusResponse::set_current_computing_request_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  current_computing_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.current_computing_request_id)
}
inline void GetStatusResponse::set_current_computing_request_id(const char* value,
    size_t size) {
  
  current_computing_request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.current_computing_request_id)
}
inline std::string* GetStatusResponse::_internal_mutable_current_computing_request_id() {
  
  return current_computing_request_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_current_computing_request_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.current_computing_request_id)
  return current_computing_request_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_current_computing_request_id(std::string* current_computing_request_id) {
  if (current_computing_request_id != nullptr) {
    
  } else {
    
  }
  current_computing_request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_computing_request_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.current_computing_request_id)
}
inline std::string* GetStatusResponse::unsafe_arena_release_current_computing_request_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.current_computing_request_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return current_computing_request_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_current_computing_request_id(
    std::string* current_computing_request_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (current_computing_request_id != nullptr) {
    
  } else {
    
  }
  current_computing_request_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      current_computing_request_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.current_computing_request_id)
}

// uint64 current_computing_start_time = 5;
inline void GetStatusResponse::clear_current_computing_start_time() {
  current_computing_start_time_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_current_computing_start_time() const {
  return current_computing_start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::current_computing_start_time() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.current_computing_start_time)
  return _internal_current_computing_start_time();
}
inline void GetStatusResponse::_internal_set_current_computing_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  current_computing_start_time_ = value;
}
inline void GetStatusResponse::set_current_computing_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_current_computing_start_time(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.current_computing_start_time)
}

// string version_proto = 6;
inline void GetStatusResponse::clear_version_proto() {
  version_proto_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::version_proto() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.version_proto)
  return _internal_version_proto();
}
inline void GetStatusResponse::set_version_proto(const std::string& value) {
  _internal_set_version_proto(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.version_proto)
}
inline std::string* GetStatusResponse::mutable_version_proto() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.version_proto)
  return _internal_mutable_version_proto();
}
inline const std::string& GetStatusResponse::_internal_version_proto() const {
  return version_proto_.Get();
}
inline void GetStatusResponse::_internal_set_version_proto(const std::string& value) {
  
  version_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_version_proto(std::string&& value) {
  
  version_proto_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.version_proto)
}
inline void GetStatusResponse::set_version_proto(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.version_proto)
}
inline void GetStatusResponse::set_version_proto(const char* value,
    size_t size) {
  
  version_proto_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.version_proto)
}
inline std::string* GetStatusResponse::_internal_mutable_version_proto() {
  
  return version_proto_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_version_proto() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.version_proto)
  return version_proto_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_version_proto(std::string* version_proto) {
  if (version_proto != nullptr) {
    
  } else {
    
  }
  version_proto_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version_proto,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.version_proto)
}
inline std::string* GetStatusResponse::unsafe_arena_release_version_proto() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.version_proto)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_proto_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_version_proto(
    std::string* version_proto) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version_proto != nullptr) {
    
  } else {
    
  }
  version_proto_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version_proto, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.version_proto)
}

// string version_server = 7;
inline void GetStatusResponse::clear_version_server() {
  version_server_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::version_server() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.version_server)
  return _internal_version_server();
}
inline void GetStatusResponse::set_version_server(const std::string& value) {
  _internal_set_version_server(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.version_server)
}
inline std::string* GetStatusResponse::mutable_version_server() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.version_server)
  return _internal_mutable_version_server();
}
inline const std::string& GetStatusResponse::_internal_version_server() const {
  return version_server_.Get();
}
inline void GetStatusResponse::_internal_set_version_server(const std::string& value) {
  
  version_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_version_server(std::string&& value) {
  
  version_server_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.version_server)
}
inline void GetStatusResponse::set_version_server(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.version_server)
}
inline void GetStatusResponse::set_version_server(const char* value,
    size_t size) {
  
  version_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.version_server)
}
inline std::string* GetStatusResponse::_internal_mutable_version_server() {
  
  return version_server_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_version_server() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.version_server)
  return version_server_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_version_server(std::string* version_server) {
  if (version_server != nullptr) {
    
  } else {
    
  }
  version_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version_server,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.version_server)
}
inline std::string* GetStatusResponse::unsafe_arena_release_version_server() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.version_server)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return version_server_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_version_server(
    std::string* version_server) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (version_server != nullptr) {
    
  } else {
    
  }
  version_server_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      version_server, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.version_server)
}

// repeated string pending_request_queue_ids = 8;
inline int GetStatusResponse::_internal_pending_request_queue_ids_size() const {
  return pending_request_queue_ids_.size();
}
inline int GetStatusResponse::pending_request_queue_ids_size() const {
  return _internal_pending_request_queue_ids_size();
}
inline void GetStatusResponse::clear_pending_request_queue_ids() {
  pending_request_queue_ids_.Clear();
}
inline std::string* GetStatusResponse::add_pending_request_queue_ids() {
  // @@protoc_insertion_point(field_add_mutable:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_add_pending_request_queue_ids();
}
inline const std::string& GetStatusResponse::_internal_pending_request_queue_ids(int index) const {
  return pending_request_queue_ids_.Get(index);
}
inline const std::string& GetStatusResponse::pending_request_queue_ids(int index) const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  return _internal_pending_request_queue_ids(index);
}
inline std::string* GetStatusResponse::mutable_pending_request_queue_ids(int index) {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  return pending_request_queue_ids_.Mutable(index);
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  pending_request_queue_ids_.Mutable(index)->assign(value);
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  pending_request_queue_ids_.Mutable(index)->assign(std::move(value));
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pending_request_queue_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::set_pending_request_queue_ids(int index, const char* value, size_t size) {
  pending_request_queue_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline std::string* GetStatusResponse::_internal_add_pending_request_queue_ids() {
  return pending_request_queue_ids_.Add();
}
inline void GetStatusResponse::add_pending_request_queue_ids(const std::string& value) {
  pending_request_queue_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(std::string&& value) {
  pending_request_queue_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pending_request_queue_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline void GetStatusResponse::add_pending_request_queue_ids(const char* value, size_t size) {
  pending_request_queue_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:multichain.v1.GetStatusResponse.pending_request_queue_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetStatusResponse::pending_request_queue_ids() const {
  // @@protoc_insertion_point(field_list:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  return pending_request_queue_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetStatusResponse::mutable_pending_request_queue_ids() {
  // @@protoc_insertion_point(field_mutable_list:multichain.v1.GetStatusResponse.pending_request_queue_ids)
  return &pending_request_queue_ids_;
}

// string prover_name = 9;
inline void GetStatusResponse::clear_prover_name() {
  prover_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::prover_name() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.prover_name)
  return _internal_prover_name();
}
inline void GetStatusResponse::set_prover_name(const std::string& value) {
  _internal_set_prover_name(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.prover_name)
}
inline std::string* GetStatusResponse::mutable_prover_name() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.prover_name)
  return _internal_mutable_prover_name();
}
inline const std::string& GetStatusResponse::_internal_prover_name() const {
  return prover_name_.Get();
}
inline void GetStatusResponse::_internal_set_prover_name(const std::string& value) {
  
  prover_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_prover_name(std::string&& value) {
  
  prover_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.prover_name)
}
inline void GetStatusResponse::set_prover_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prover_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.prover_name)
}
inline void GetStatusResponse::set_prover_name(const char* value,
    size_t size) {
  
  prover_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.prover_name)
}
inline std::string* GetStatusResponse::_internal_mutable_prover_name() {
  
  return prover_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_prover_name() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.prover_name)
  return prover_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_prover_name(std::string* prover_name) {
  if (prover_name != nullptr) {
    
  } else {
    
  }
  prover_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.prover_name)
}
inline std::string* GetStatusResponse::unsafe_arena_release_prover_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.prover_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prover_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_prover_name(
    std::string* prover_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prover_name != nullptr) {
    
  } else {
    
  }
  prover_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prover_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.prover_name)
}

// string prover_id = 10;
inline void GetStatusResponse::clear_prover_id() {
  prover_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetStatusResponse::prover_id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.prover_id)
  return _internal_prover_id();
}
inline void GetStatusResponse::set_prover_id(const std::string& value) {
  _internal_set_prover_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.prover_id)
}
inline std::string* GetStatusResponse::mutable_prover_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetStatusResponse.prover_id)
  return _internal_mutable_prover_id();
}
inline const std::string& GetStatusResponse::_internal_prover_id() const {
  return prover_id_.Get();
}
inline void GetStatusResponse::_internal_set_prover_id(const std::string& value) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetStatusResponse::set_prover_id(std::string&& value) {
  
  prover_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetStatusResponse.prover_id)
}
inline void GetStatusResponse::set_prover_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetStatusResponse.prover_id)
}
inline void GetStatusResponse::set_prover_id(const char* value,
    size_t size) {
  
  prover_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetStatusResponse.prover_id)
}
inline std::string* GetStatusResponse::_internal_mutable_prover_id() {
  
  return prover_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetStatusResponse::release_prover_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetStatusResponse.prover_id)
  return prover_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetStatusResponse::set_allocated_prover_id(std::string* prover_id) {
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetStatusResponse.prover_id)
}
inline std::string* GetStatusResponse::unsafe_arena_release_prover_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetStatusResponse.prover_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return prover_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetStatusResponse::unsafe_arena_set_allocated_prover_id(
    std::string* prover_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (prover_id != nullptr) {
    
  } else {
    
  }
  prover_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      prover_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetStatusResponse.prover_id)
}

// uint64 number_of_cores = 11;
inline void GetStatusResponse::clear_number_of_cores() {
  number_of_cores_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_number_of_cores() const {
  return number_of_cores_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::number_of_cores() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.number_of_cores)
  return _internal_number_of_cores();
}
inline void GetStatusResponse::_internal_set_number_of_cores(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  number_of_cores_ = value;
}
inline void GetStatusResponse::set_number_of_cores(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_number_of_cores(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.number_of_cores)
}

// uint64 total_memory = 12;
inline void GetStatusResponse::clear_total_memory() {
  total_memory_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_total_memory() const {
  return total_memory_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::total_memory() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.total_memory)
  return _internal_total_memory();
}
inline void GetStatusResponse::_internal_set_total_memory(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_memory_ = value;
}
inline void GetStatusResponse::set_total_memory(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_memory(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.total_memory)
}

// uint64 free_memory = 13;
inline void GetStatusResponse::clear_free_memory() {
  free_memory_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_free_memory() const {
  return free_memory_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::free_memory() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.free_memory)
  return _internal_free_memory();
}
inline void GetStatusResponse::_internal_set_free_memory(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  free_memory_ = value;
}
inline void GetStatusResponse::set_free_memory(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_free_memory(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.free_memory)
}

// uint64 fork_id = 14;
inline void GetStatusResponse::clear_fork_id() {
  fork_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::_internal_fork_id() const {
  return fork_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetStatusResponse::fork_id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetStatusResponse.fork_id)
  return _internal_fork_id();
}
inline void GetStatusResponse::_internal_set_fork_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  fork_id_ = value;
}
inline void GetStatusResponse::set_fork_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fork_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetStatusResponse.fork_id)
}

// -------------------------------------------------------------------

// GenPrepareMultichainProofResponse

// string id = 1;
inline void GenPrepareMultichainProofResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenPrepareMultichainProofResponse::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenPrepareMultichainProofResponse.id)
  return _internal_id();
}
inline void GenPrepareMultichainProofResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenPrepareMultichainProofResponse.id)
}
inline std::string* GenPrepareMultichainProofResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenPrepareMultichainProofResponse.id)
  return _internal_mutable_id();
}
inline const std::string& GenPrepareMultichainProofResponse::_internal_id() const {
  return id_.Get();
}
inline void GenPrepareMultichainProofResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenPrepareMultichainProofResponse::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenPrepareMultichainProofResponse.id)
}
inline void GenPrepareMultichainProofResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenPrepareMultichainProofResponse.id)
}
inline void GenPrepareMultichainProofResponse::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenPrepareMultichainProofResponse.id)
}
inline std::string* GenPrepareMultichainProofResponse::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenPrepareMultichainProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenPrepareMultichainProofResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenPrepareMultichainProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenPrepareMultichainProofResponse.id)
}
inline std::string* GenPrepareMultichainProofResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenPrepareMultichainProofResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenPrepareMultichainProofResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenPrepareMultichainProofResponse.id)
}

// .multichain.v1.Result result = 2;
inline void GenPrepareMultichainProofResponse::clear_result() {
  result_ = 0;
}
inline ::multichain::v1::Result GenPrepareMultichainProofResponse::_internal_result() const {
  return static_cast< ::multichain::v1::Result >(result_);
}
inline ::multichain::v1::Result GenPrepareMultichainProofResponse::result() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenPrepareMultichainProofResponse.result)
  return _internal_result();
}
inline void GenPrepareMultichainProofResponse::_internal_set_result(::multichain::v1::Result value) {
  
  result_ = value;
}
inline void GenPrepareMultichainProofResponse::set_result(::multichain::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenPrepareMultichainProofResponse.result)
}

// -------------------------------------------------------------------

// GenAggregatedMultichainProofResponse

// string id = 1;
inline void GenAggregatedMultichainProofResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenAggregatedMultichainProofResponse::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenAggregatedMultichainProofResponse.id)
  return _internal_id();
}
inline void GenAggregatedMultichainProofResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenAggregatedMultichainProofResponse.id)
}
inline std::string* GenAggregatedMultichainProofResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenAggregatedMultichainProofResponse.id)
  return _internal_mutable_id();
}
inline const std::string& GenAggregatedMultichainProofResponse::_internal_id() const {
  return id_.Get();
}
inline void GenAggregatedMultichainProofResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenAggregatedMultichainProofResponse::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenAggregatedMultichainProofResponse.id)
}
inline void GenAggregatedMultichainProofResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenAggregatedMultichainProofResponse.id)
}
inline void GenAggregatedMultichainProofResponse::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenAggregatedMultichainProofResponse.id)
}
inline std::string* GenAggregatedMultichainProofResponse::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenAggregatedMultichainProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenAggregatedMultichainProofResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenAggregatedMultichainProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenAggregatedMultichainProofResponse.id)
}
inline std::string* GenAggregatedMultichainProofResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenAggregatedMultichainProofResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenAggregatedMultichainProofResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenAggregatedMultichainProofResponse.id)
}

// .multichain.v1.Result result = 2;
inline void GenAggregatedMultichainProofResponse::clear_result() {
  result_ = 0;
}
inline ::multichain::v1::Result GenAggregatedMultichainProofResponse::_internal_result() const {
  return static_cast< ::multichain::v1::Result >(result_);
}
inline ::multichain::v1::Result GenAggregatedMultichainProofResponse::result() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenAggregatedMultichainProofResponse.result)
  return _internal_result();
}
inline void GenAggregatedMultichainProofResponse::_internal_set_result(::multichain::v1::Result value) {
  
  result_ = value;
}
inline void GenAggregatedMultichainProofResponse::set_result(::multichain::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenAggregatedMultichainProofResponse.result)
}

// -------------------------------------------------------------------

// GenFinalMultichainProofResponse

// string id = 1;
inline void GenFinalMultichainProofResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GenFinalMultichainProofResponse::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenFinalMultichainProofResponse.id)
  return _internal_id();
}
inline void GenFinalMultichainProofResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenFinalMultichainProofResponse.id)
}
inline std::string* GenFinalMultichainProofResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GenFinalMultichainProofResponse.id)
  return _internal_mutable_id();
}
inline const std::string& GenFinalMultichainProofResponse::_internal_id() const {
  return id_.Get();
}
inline void GenFinalMultichainProofResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenFinalMultichainProofResponse::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GenFinalMultichainProofResponse.id)
}
inline void GenFinalMultichainProofResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GenFinalMultichainProofResponse.id)
}
inline void GenFinalMultichainProofResponse::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GenFinalMultichainProofResponse.id)
}
inline std::string* GenFinalMultichainProofResponse::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenFinalMultichainProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GenFinalMultichainProofResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenFinalMultichainProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GenFinalMultichainProofResponse.id)
}
inline std::string* GenFinalMultichainProofResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GenFinalMultichainProofResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenFinalMultichainProofResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GenFinalMultichainProofResponse.id)
}

// .multichain.v1.Result result = 2;
inline void GenFinalMultichainProofResponse::clear_result() {
  result_ = 0;
}
inline ::multichain::v1::Result GenFinalMultichainProofResponse::_internal_result() const {
  return static_cast< ::multichain::v1::Result >(result_);
}
inline ::multichain::v1::Result GenFinalMultichainProofResponse::result() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GenFinalMultichainProofResponse.result)
  return _internal_result();
}
inline void GenFinalMultichainProofResponse::_internal_set_result(::multichain::v1::Result value) {
  
  result_ = value;
}
inline void GenFinalMultichainProofResponse::set_result(::multichain::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GenFinalMultichainProofResponse.result)
}

// -------------------------------------------------------------------

// CancelResponse

// .multichain.v1.Result result = 1;
inline void CancelResponse::clear_result() {
  result_ = 0;
}
inline ::multichain::v1::Result CancelResponse::_internal_result() const {
  return static_cast< ::multichain::v1::Result >(result_);
}
inline ::multichain::v1::Result CancelResponse::result() const {
  // @@protoc_insertion_point(field_get:multichain.v1.CancelResponse.result)
  return _internal_result();
}
inline void CancelResponse::_internal_set_result(::multichain::v1::Result value) {
  
  result_ = value;
}
inline void CancelResponse::set_result(::multichain::v1::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:multichain.v1.CancelResponse.result)
}

// -------------------------------------------------------------------

// GetProofResponse

// string id = 1;
inline void GetProofResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetProofResponse::id() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofResponse.id)
  return _internal_id();
}
inline void GetProofResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofResponse.id)
}
inline std::string* GetProofResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetProofResponse.id)
  return _internal_mutable_id();
}
inline const std::string& GetProofResponse::_internal_id() const {
  return id_.Get();
}
inline void GetProofResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProofResponse::set_id(std::string&& value) {
  
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetProofResponse.id)
}
inline void GetProofResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetProofResponse.id)
}
inline void GetProofResponse::set_id(const char* value,
    size_t size) {
  
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetProofResponse.id)
}
inline std::string* GetProofResponse::_internal_mutable_id() {
  
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProofResponse::release_id() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetProofResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetProofResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetProofResponse.id)
}
inline std::string* GetProofResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetProofResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetProofResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    
  } else {
    
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetProofResponse.id)
}

// .multichain.v1.PrepareProof prepare_proof = 2;
inline bool GetProofResponse::_internal_has_prepare_proof() const {
  return proof_case() == kPrepareProof;
}
inline bool GetProofResponse::has_prepare_proof() const {
  return _internal_has_prepare_proof();
}
inline void GetProofResponse::set_has_prepare_proof() {
  _oneof_case_[0] = kPrepareProof;
}
inline void GetProofResponse::clear_prepare_proof() {
  if (_internal_has_prepare_proof()) {
    if (GetArena() == nullptr) {
      delete proof_.prepare_proof_;
    }
    clear_has_proof();
  }
}
inline ::multichain::v1::PrepareProof* GetProofResponse::release_prepare_proof() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetProofResponse.prepare_proof)
  if (_internal_has_prepare_proof()) {
    clear_has_proof();
      ::multichain::v1::PrepareProof* temp = proof_.prepare_proof_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    proof_.prepare_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::multichain::v1::PrepareProof& GetProofResponse::_internal_prepare_proof() const {
  return _internal_has_prepare_proof()
      ? *proof_.prepare_proof_
      : *reinterpret_cast< ::multichain::v1::PrepareProof*>(&::multichain::v1::_PrepareProof_default_instance_);
}
inline const ::multichain::v1::PrepareProof& GetProofResponse::prepare_proof() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofResponse.prepare_proof)
  return _internal_prepare_proof();
}
inline ::multichain::v1::PrepareProof* GetProofResponse::unsafe_arena_release_prepare_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetProofResponse.prepare_proof)
  if (_internal_has_prepare_proof()) {
    clear_has_proof();
    ::multichain::v1::PrepareProof* temp = proof_.prepare_proof_;
    proof_.prepare_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::unsafe_arena_set_allocated_prepare_proof(::multichain::v1::PrepareProof* prepare_proof) {
  clear_proof();
  if (prepare_proof) {
    set_has_prepare_proof();
    proof_.prepare_proof_ = prepare_proof;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetProofResponse.prepare_proof)
}
inline ::multichain::v1::PrepareProof* GetProofResponse::_internal_mutable_prepare_proof() {
  if (!_internal_has_prepare_proof()) {
    clear_proof();
    set_has_prepare_proof();
    proof_.prepare_proof_ = CreateMaybeMessage< ::multichain::v1::PrepareProof >(GetArena());
  }
  return proof_.prepare_proof_;
}
inline ::multichain::v1::PrepareProof* GetProofResponse::mutable_prepare_proof() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetProofResponse.prepare_proof)
  return _internal_mutable_prepare_proof();
}

// string multichain_proof = 3;
inline bool GetProofResponse::_internal_has_multichain_proof() const {
  return proof_case() == kMultichainProof;
}
inline void GetProofResponse::set_has_multichain_proof() {
  _oneof_case_[0] = kMultichainProof;
}
inline void GetProofResponse::clear_multichain_proof() {
  if (_internal_has_multichain_proof()) {
    proof_.multichain_proof_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
    clear_has_proof();
  }
}
inline const std::string& GetProofResponse::multichain_proof() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofResponse.multichain_proof)
  return _internal_multichain_proof();
}
inline void GetProofResponse::set_multichain_proof(const std::string& value) {
  _internal_set_multichain_proof(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofResponse.multichain_proof)
}
inline std::string* GetProofResponse::mutable_multichain_proof() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetProofResponse.multichain_proof)
  return _internal_mutable_multichain_proof();
}
inline const std::string& GetProofResponse::_internal_multichain_proof() const {
  if (_internal_has_multichain_proof()) {
    return proof_.multichain_proof_.Get();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void GetProofResponse::_internal_set_multichain_proof(const std::string& value) {
  if (!_internal_has_multichain_proof()) {
    clear_proof();
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  proof_.multichain_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProofResponse::set_multichain_proof(std::string&& value) {
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofResponse.multichain_proof)
  if (!_internal_has_multichain_proof()) {
    clear_proof();
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  proof_.multichain_proof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetProofResponse.multichain_proof)
}
inline void GetProofResponse::set_multichain_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_multichain_proof()) {
    clear_proof();
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  proof_.multichain_proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetProofResponse.multichain_proof)
}
inline void GetProofResponse::set_multichain_proof(const char* value,
                             size_t size) {
  if (!_internal_has_multichain_proof()) {
    clear_proof();
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  proof_.multichain_proof_.Set(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetProofResponse.multichain_proof)
}
inline std::string* GetProofResponse::_internal_mutable_multichain_proof() {
  if (!_internal_has_multichain_proof()) {
    clear_proof();
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return proof_.multichain_proof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProofResponse::release_multichain_proof() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetProofResponse.multichain_proof)
  if (_internal_has_multichain_proof()) {
    clear_has_proof();
    return proof_.multichain_proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::set_allocated_multichain_proof(std::string* multichain_proof) {
  if (has_proof()) {
    clear_proof();
  }
  if (multichain_proof != nullptr) {
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeSetDefault(multichain_proof);
  }
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetProofResponse.multichain_proof)
}
inline std::string* GetProofResponse::unsafe_arena_release_multichain_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetProofResponse.multichain_proof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (_internal_has_multichain_proof()) {
    clear_has_proof();
    return proof_.multichain_proof_.UnsafeArenaRelease(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void GetProofResponse::unsafe_arena_set_allocated_multichain_proof(std::string* multichain_proof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (!_internal_has_multichain_proof()) {
    proof_.multichain_proof_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  clear_proof();
  if (multichain_proof) {
    set_has_multichain_proof();
    proof_.multichain_proof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), multichain_proof, GetArena());
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetProofResponse.multichain_proof)
}

// .multichain.v1.GetProofResponse.Result result = 4;
inline void GetProofResponse::clear_result() {
  result_ = 0;
}
inline ::multichain::v1::GetProofResponse_Result GetProofResponse::_internal_result() const {
  return static_cast< ::multichain::v1::GetProofResponse_Result >(result_);
}
inline ::multichain::v1::GetProofResponse_Result GetProofResponse::result() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofResponse.result)
  return _internal_result();
}
inline void GetProofResponse::_internal_set_result(::multichain::v1::GetProofResponse_Result value) {
  
  result_ = value;
}
inline void GetProofResponse::set_result(::multichain::v1::GetProofResponse_Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofResponse.result)
}

// string result_string = 5;
inline void GetProofResponse::clear_result_string() {
  result_string_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetProofResponse::result_string() const {
  // @@protoc_insertion_point(field_get:multichain.v1.GetProofResponse.result_string)
  return _internal_result_string();
}
inline void GetProofResponse::set_result_string(const std::string& value) {
  _internal_set_result_string(value);
  // @@protoc_insertion_point(field_set:multichain.v1.GetProofResponse.result_string)
}
inline std::string* GetProofResponse::mutable_result_string() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.GetProofResponse.result_string)
  return _internal_mutable_result_string();
}
inline const std::string& GetProofResponse::_internal_result_string() const {
  return result_string_.Get();
}
inline void GetProofResponse::_internal_set_result_string(const std::string& value) {
  
  result_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetProofResponse::set_result_string(std::string&& value) {
  
  result_string_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.GetProofResponse.result_string)
}
inline void GetProofResponse::set_result_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  result_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.GetProofResponse.result_string)
}
inline void GetProofResponse::set_result_string(const char* value,
    size_t size) {
  
  result_string_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.GetProofResponse.result_string)
}
inline std::string* GetProofResponse::_internal_mutable_result_string() {
  
  return result_string_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetProofResponse::release_result_string() {
  // @@protoc_insertion_point(field_release:multichain.v1.GetProofResponse.result_string)
  return result_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetProofResponse::set_allocated_result_string(std::string* result_string) {
  if (result_string != nullptr) {
    
  } else {
    
  }
  result_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.GetProofResponse.result_string)
}
inline std::string* GetProofResponse::unsafe_arena_release_result_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.GetProofResponse.result_string)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return result_string_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetProofResponse::unsafe_arena_set_allocated_result_string(
    std::string* result_string) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (result_string != nullptr) {
    
  } else {
    
  }
  result_string_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      result_string, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.GetProofResponse.result_string)
}

inline bool GetProofResponse::has_proof() const {
  return proof_case() != PROOF_NOT_SET;
}
inline void GetProofResponse::clear_has_proof() {
  _oneof_case_[0] = PROOF_NOT_SET;
}
inline GetProofResponse::ProofCase GetProofResponse::proof_case() const {
  return GetProofResponse::ProofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PrepareProof

// string proof = 1;
inline void PrepareProof::clear_proof() {
  proof_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PrepareProof::proof() const {
  // @@protoc_insertion_point(field_get:multichain.v1.PrepareProof.proof)
  return _internal_proof();
}
inline void PrepareProof::set_proof(const std::string& value) {
  _internal_set_proof(value);
  // @@protoc_insertion_point(field_set:multichain.v1.PrepareProof.proof)
}
inline std::string* PrepareProof::mutable_proof() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.PrepareProof.proof)
  return _internal_mutable_proof();
}
inline const std::string& PrepareProof::_internal_proof() const {
  return proof_.Get();
}
inline void PrepareProof::_internal_set_proof(const std::string& value) {
  
  proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PrepareProof::set_proof(std::string&& value) {
  
  proof_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.PrepareProof.proof)
}
inline void PrepareProof::set_proof(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.PrepareProof.proof)
}
inline void PrepareProof::set_proof(const char* value,
    size_t size) {
  
  proof_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.PrepareProof.proof)
}
inline std::string* PrepareProof::_internal_mutable_proof() {
  
  return proof_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PrepareProof::release_proof() {
  // @@protoc_insertion_point(field_release:multichain.v1.PrepareProof.proof)
  return proof_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PrepareProof::set_allocated_proof(std::string* proof) {
  if (proof != nullptr) {
    
  } else {
    
  }
  proof_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), proof,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.PrepareProof.proof)
}
inline std::string* PrepareProof::unsafe_arena_release_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.PrepareProof.proof)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return proof_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PrepareProof::unsafe_arena_set_allocated_proof(
    std::string* proof) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (proof != nullptr) {
    
  } else {
    
  }
  proof_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      proof, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.PrepareProof.proof)
}

// string hash_info = 2;
inline void PrepareProof::clear_hash_info() {
  hash_info_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PrepareProof::hash_info() const {
  // @@protoc_insertion_point(field_get:multichain.v1.PrepareProof.hash_info)
  return _internal_hash_info();
}
inline void PrepareProof::set_hash_info(const std::string& value) {
  _internal_set_hash_info(value);
  // @@protoc_insertion_point(field_set:multichain.v1.PrepareProof.hash_info)
}
inline std::string* PrepareProof::mutable_hash_info() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.PrepareProof.hash_info)
  return _internal_mutable_hash_info();
}
inline const std::string& PrepareProof::_internal_hash_info() const {
  return hash_info_.Get();
}
inline void PrepareProof::_internal_set_hash_info(const std::string& value) {
  
  hash_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PrepareProof::set_hash_info(std::string&& value) {
  
  hash_info_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.PrepareProof.hash_info)
}
inline void PrepareProof::set_hash_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.PrepareProof.hash_info)
}
inline void PrepareProof::set_hash_info(const char* value,
    size_t size) {
  
  hash_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.PrepareProof.hash_info)
}
inline std::string* PrepareProof::_internal_mutable_hash_info() {
  
  return hash_info_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PrepareProof::release_hash_info() {
  // @@protoc_insertion_point(field_release:multichain.v1.PrepareProof.hash_info)
  return hash_info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PrepareProof::set_allocated_hash_info(std::string* hash_info) {
  if (hash_info != nullptr) {
    
  } else {
    
  }
  hash_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_info,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.PrepareProof.hash_info)
}
inline std::string* PrepareProof::unsafe_arena_release_hash_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.PrepareProof.hash_info)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return hash_info_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PrepareProof::unsafe_arena_set_allocated_hash_info(
    std::string* hash_info) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash_info != nullptr) {
    
  } else {
    
  }
  hash_info_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash_info, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.PrepareProof.hash_info)
}

// -------------------------------------------------------------------

// CalculateSha256Response

// string out_hash = 1;
inline void CalculateSha256Response::clear_out_hash() {
  out_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CalculateSha256Response::out_hash() const {
  // @@protoc_insertion_point(field_get:multichain.v1.CalculateSha256Response.out_hash)
  return _internal_out_hash();
}
inline void CalculateSha256Response::set_out_hash(const std::string& value) {
  _internal_set_out_hash(value);
  // @@protoc_insertion_point(field_set:multichain.v1.CalculateSha256Response.out_hash)
}
inline std::string* CalculateSha256Response::mutable_out_hash() {
  // @@protoc_insertion_point(field_mutable:multichain.v1.CalculateSha256Response.out_hash)
  return _internal_mutable_out_hash();
}
inline const std::string& CalculateSha256Response::_internal_out_hash() const {
  return out_hash_.Get();
}
inline void CalculateSha256Response::_internal_set_out_hash(const std::string& value) {
  
  out_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CalculateSha256Response::set_out_hash(std::string&& value) {
  
  out_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:multichain.v1.CalculateSha256Response.out_hash)
}
inline void CalculateSha256Response::set_out_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  out_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:multichain.v1.CalculateSha256Response.out_hash)
}
inline void CalculateSha256Response::set_out_hash(const char* value,
    size_t size) {
  
  out_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:multichain.v1.CalculateSha256Response.out_hash)
}
inline std::string* CalculateSha256Response::_internal_mutable_out_hash() {
  
  return out_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CalculateSha256Response::release_out_hash() {
  // @@protoc_insertion_point(field_release:multichain.v1.CalculateSha256Response.out_hash)
  return out_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CalculateSha256Response::set_allocated_out_hash(std::string* out_hash) {
  if (out_hash != nullptr) {
    
  } else {
    
  }
  out_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), out_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:multichain.v1.CalculateSha256Response.out_hash)
}
inline std::string* CalculateSha256Response::unsafe_arena_release_out_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:multichain.v1.CalculateSha256Response.out_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return out_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CalculateSha256Response::unsafe_arena_set_allocated_out_hash(
    std::string* out_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (out_hash != nullptr) {
    
  } else {
    
  }
  out_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      out_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:multichain.v1.CalculateSha256Response.out_hash)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace multichain

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::multichain::v1::GetStatusResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::multichain::v1::GetStatusResponse_Status>() {
  return ::multichain::v1::GetStatusResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::multichain::v1::GetProofResponse_Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::multichain::v1::GetProofResponse_Result>() {
  return ::multichain::v1::GetProofResponse_Result_descriptor();
}
template <> struct is_proto_enum< ::multichain::v1::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::multichain::v1::Result>() {
  return ::multichain::v1::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_multichain_2eproto
